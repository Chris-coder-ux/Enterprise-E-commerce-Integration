/**
 * Verificador de compatibilidad y diagn√≥stico del dashboard
 * 
 * Este c√≥digo se ejecuta autom√°ticamente al cargar la p√°gina para verificar
 * la compatibilidad del navegador y detectar problemas comunes que pueden
 * afectar el funcionamiento del dashboard de Mi Integraci√≥n API.
 * 
 * @function compatibilityChecker
 * @description Verifica la compatibilidad del navegador y jQuery
 * @returns {void}
 * @since 1.0.0
 * @author Christian
 * @example
 * // Se ejecuta autom√°ticamente al cargar la p√°gina
 * compatibilityChecker();
 */

/* global miIntegracionApiDashboard, AjaxManager, jQuery, originalSyncButtonText, pollingManager, syncInterval, BasicDiagnosticAPI, globalThis, global, Phase1Manager, Phase2Manager, SyncController, SyncDashboard, UnifiedDashboard, ResponsiveLayout, CardManager, UnifiedDashboardController, SyncStateManager */

/**
 * ========================================
 * ARQUITECTURA DE VARIABLES GLOBALES
 * ========================================
 * 
 * Este archivo expone las siguientes variables globales con responsabilidades espec√≠ficas:
 * 
 * @namespace GlobalVariables
 * @description Variables globales del sistema de dashboard
 * 
 * @property {Object} window.AjaxManager - Gesti√≥n centralizada de peticiones AJAX
 * @property {Object} window.ErrorHandler - Manejo centralizado de errores
 * @property {Object} window.SystemEventManager - Gesti√≥n de eventos del sistema
 * @property {Object} SystemEventManager - Gesti√≥n de eventos del sistema (uso directo)
 * @property {Object} window.BasicDiagnosticAPI - API b√°sica de diagn√≥stico
 * @property {Object} ResponsiveLayout - Sistema de layout responsive (uso directo)
 * @property {Object} window.UnifiedDashboard - Dashboard unificado completo
 * @property {Object} UnifiedDashboard - Dashboard unificado completo (uso directo)
 * 
 * @example
 * // Uso de las variables globales
 * window.AjaxManager.call('action', data, success, error);
 * window.ErrorHandler.showUIError('Error message');
 * window.SystemEventManager.init();
 * 
 * // Uso directo del dashboard (recomendado)
 * UnifiedDashboard.init();
 * UnifiedDashboard.runSystemDiagnostic();
 * 
 * // Uso directo del sistema de eventos (recomendado)
 * SystemEventManager.init();
 * SystemEventManager.registerSystem('miSistema', ['jQuery'], callback);
 * 
 * // Uso directo del sistema responsive (recomendado)
 * ResponsiveLayout.init();
 * ResponsiveLayout.adjustLayout();
 * 
 * @since 1.0.0
 * @author Christian
 */

(function() {
  // Verificaci√≥n simple de jQuery
  if (typeof jQuery !== 'undefined') {
    // jQuery est√° disponible, continuar con la inicializaci√≥n
  } else {
    console.error('jQuery no est√° disponible. El dashboard no funcionar√°.');
  }

    // ========================================
  // CONSTANTES CONFIGURABLES
  // ========================================
  
  // Variable global para almacenar el texto original del bot√≥n de sincronizaci√≥n
  window.originalSyncButtonText = 'Sincronizar productos en lote';

    /**
     * Informaci√≥n del navegador y compatibilidad
     * @type {Object}
     * @property {string} userAgent - User agent del navegador
     * @property {string} vendor - Vendor del navegador
     * @property {string} platform - Plataforma del sistema
     * @property {string} jQueryVersion - Versi√≥n de jQuery disponible
     * @property {string} online - Estado de conexi√≥n
     * @property {boolean} ajaxAvailable - Disponibilidad de AJAX
     * @property {boolean} cookiesEnabled - Estado de las cookies
     * @property {boolean} localStorage - Disponibilidad de localStorage
     * @property {string} screenSize - Tama√±o de pantalla
     */
})();

// ========================================
// CONFIGURACI√ìN GLOBAL DEL DASHBOARD
// ========================================

/**
 * Configuraci√≥n global del dashboard
 * @type {Object}
 * @namespace DASHBOARD_CONFIG
 * @description Configuraci√≥n centralizada para el dashboard de Mi Integraci√≥n API
 */
const DASHBOARD_CONFIG = {
  /**
   * Configuraci√≥n de timeouts para operaciones del dashboard
   * @type {Object}
   * @property {number} default - Timeout por defecto (2000ms)
   * @property {number} long - Timeout para operaciones largas (5000ms)
   * @property {number} short - Timeout para operaciones cortas (1000ms)
   * @property {number} ajax - Timeout para peticiones AJAX (60000ms)
   * @property {number} connection - Timeout para verificaci√≥n de conexi√≥n (60000ms)
   */
  timeouts: (() => {
    try {
      // Verificar si miIntegracionApiDashboard existe y tiene timeoutConfig
      if (typeof miIntegracionApiDashboard !== 'undefined' && 
          miIntegracionApiDashboard && 
          miIntegracionApiDashboard.timeoutConfig && 
          miIntegracionApiDashboard.timeoutConfig.ui) {
        return miIntegracionApiDashboard.timeoutConfig.ui;
      }
    } catch (error) {
      console.warn('Error accediendo a miIntegracionApiDashboard.timeoutConfig:', error);
    }
    
    // Fallback por defecto si no hay configuraci√≥n disponible
    return {
      default: 2000,
      long: 5000,
      short: 1000,
      ajax: 60000,
      connection: 30000  // Reducido de 60000 a 30000 para mejor UX
    };
  })(),
  
  /**
   * L√≠mites y configuraciones de rendimiento
   * @type {Object}
   * @property {number} historyLimit - L√≠mite de historial (10)
   * @property {number[]} progressMilestones - Hitos de progreso [25, 50, 75, 100]
   */
  limits: (() => {
    try {
      // Verificar si miIntegracionApiDashboard existe y tiene limitsConfig
      if (typeof miIntegracionApiDashboard !== 'undefined' && 
          miIntegracionApiDashboard && 
          miIntegracionApiDashboard.limitsConfig && 
          miIntegracionApiDashboard.limitsConfig.ui) {
        return miIntegracionApiDashboard.limitsConfig.ui;
      }
    } catch (error) {
      console.warn('Error accediendo a miIntegracionApiDashboard.limitsConfig:', error);
    }
    
    // Fallback por defecto si no hay configuraci√≥n disponible
    return {
      historyLimit: 10,
      progressMilestones: [25, 50, 75, 100]
    };
  })(),
  
  /**
   * Selectores CSS para elementos del dashboard
   * @type {Object}
   * @property {string} syncButton - Selector del bot√≥n de sincronizaci√≥n
   * @property {string} feedback - Selector del √°rea de feedback
   * @property {string} progressInfo - Selector de informaci√≥n de progreso
   * @property {string} cancelButton - Selector del bot√≥n de cancelar
   * @property {string} statusContainer - Selector del contenedor de estado
   * @property {string} batchSize - Selector del selector de tama√±o de lote
   * @property {string} dashboardMessages - Selector de mensajes del dashboard
   * @property {string} retryButton - Selector del bot√≥n de reintento
   */
  selectors: {
    syncButton: '#mi-batch-sync-products',
    feedback: '#mi-sync-feedback',
    progressInfo: '#mi-progress-info',
    cancelButton: '#mi-cancel-sync',
    statusContainer: '#mi-sync-status-details',
    batchSize: '#mi-batch-size',
    dashboardMessages: '#mi-dashboard-messages',
    retryButton: '#mi-api-retry-sync'
  },
  
  /**
   * Mensajes del sistema organizados por categor√≠as
   * @type {Object}
   * @property {Object} errors - Mensajes de error
   * @property {Object} progress - Mensajes de progreso
   * @property {Object} milestones - Mensajes de hitos
   * @property {Object} tips - Consejos y tips
   */
  messages: {
    /**
     * Mensajes de error del sistema
     * @type {Object}
     * @property {string} jqueryMissing - Error cuando jQuery no est√° disponible
     * @property {string} configMissing - Error de configuraci√≥n incompleta
     * @property {string} ajaxUrlMissing - Error cuando ajaxurl no est√° definido
     * @property {string} connectionError - Error de conexi√≥n
     * @property {string} permissionError - Error de permisos (403)
     * @property {string} serverError - Error del servidor (500)
     * @property {string} timeoutError - Error de timeout
     * @property {string} unknownError - Error desconocido
     */
    errors: {
      jqueryMissing: 'jQuery no est√° disponible. El dashboard no funcionar√°.',
      configMissing: 'Variables de configuraci√≥n incompletas. La sincronizaci√≥n fallar√°.',
      ajaxUrlMissing: 'Variable ajaxurl no est√° definida. La sincronizaci√≥n AJAX fallar√°.',
      connectionError: 'Error de conexi√≥n. Verifique su conexi√≥n a internet.',
      permissionError: 'Error de permisos (403). Por favor, recarga la p√°gina o inicia sesi√≥n nuevamente.',
      serverError: 'Error del servidor (500). Contacte al administrador.',
      timeoutError: 'Tiempo de espera agotado. La operaci√≥n tard√≥ demasiado.',
      unknownError: 'Error desconocido. Verifique la consola para m√°s detalles.'
    },
    /**
     * Mensajes de progreso de sincronizaci√≥n
     * @type {Object}
     * @property {string} preparing - Mensaje de preparaci√≥n
     * @property {string} verifying - Mensaje de verificaci√≥n
     * @property {string} connecting - Mensaje de conexi√≥n
     * @property {string} processing - Mensaje de procesamiento
     * @property {string} complete - Mensaje de completado
     */
    progress: {
      preparing: 'Preparando sincronizaci√≥n... ',
      verifying: 'Verificando estado del servidor...',
      connecting: 'Conectando con el servidor...',
      processing: 'Procesando datos...',
      complete: 'Sincronizaci√≥n completada exitosamente'
    },
    /**
     * Mensajes de hitos de progreso
     * @type {Object}
     * @property {string} start - Mensaje de inicio
     * @property {string} quarter - Mensaje de 25% completado
     * @property {string} half - Mensaje de 50% completado
     * @property {string} threeQuarters - Mensaje de 75% completado
     * @property {string} complete - Mensaje de completado
     */
    milestones: {
      start: 'Iniciando sincronizaci√≥n...',
      quarter: '25% completado',
      half: '50% completado',
      threeQuarters: '75% completado',
      complete: '¬°Sincronizaci√≥n completada!'
    },
    /**
     * Mensajes de √©xito del sistema
     * @type {Object}
     * @property {string} batchSizeChanged - Mensaje cuando se cambia el tama√±o de lote
     */
    success: {
      batchSizeChanged: 'Tama√±o de lote cambiado a {size} productos'
    },
    /**
     * Consejos y tips para el usuario
     * @type {Object}
     * @property {string} keyboardShortcut - Atajo de teclado
     * @property {string} generalTip - Tip general
     */
    tips: {
      keyboardShortcut: 'Atajo de teclado: Ctrl+Enter para sincronizar',
      generalTip: 'üí° Tip: Usa Ctrl+Enter para iniciar sincronizaci√≥n r√°pida'
    }
  },
  
  /**
   * Configuraci√≥n de interfaz de usuario
   * @type {Object}
   * @property {Object} progress - Configuraci√≥n de barras de progreso
   * @property {Object} animation - Configuraci√≥n de animaciones
   * @property {Object} toastDuration - Duraci√≥n de notificaciones toast
   */
  ui: {
    /**
     * Configuraci√≥n de barras de progreso
     * @type {Object}
     * @property {number} defaultWidth - Ancho por defecto (2px)
     * @property {number} animationDuration - Duraci√≥n de animaci√≥n (300ms)
     * @property {Object} colorScheme - Esquema de colores
     */
    progress: {
      defaultWidth: 2,
      animationDuration: 300,
      colorScheme: {
        normal: '#0073aa',
        success: '#22c55e',
        warning: '#f59e0b',
        error: '#ef4444'
      }
    },
    /**
     * Configuraci√≥n de animaciones
     * @type {Object}
     * @property {number} duration - Duraci√≥n de animaci√≥n (300ms)
     * @property {string} easing - Tipo de easing ('swing')
     */
    animation: {
      duration: 300,
      easing: 'swing'
    },
    /**
     * Duraci√≥n de notificaciones toast
     * @type {Object}
     * @property {number} short - Duraci√≥n corta (3000ms)
     * @property {number} medium - Duraci√≥n media (5000ms)
     * @property {number} long - Duraci√≥n larga (8000ms)
     * @property {number} extraLong - Duraci√≥n extra larga (10000ms)
     */
    toastDuration: {
      short: 3000,
      medium: 5000,
      long: 8000,
      extraLong: 10000
    }
  },
  
  /**
   * Configuraci√≥n de paginaci√≥n
   * @type {Object}
   * @property {number} defaultPerPage - Elementos por p√°gina por defecto (10)
   * @property {number} debounceDelay - Delay de debounce (500ms)
   * @property {number} maxVisiblePages - M√°ximo de p√°ginas visibles (5)
   */
  pagination: {
    defaultPerPage: 10,
    debounceDelay: 500,
    maxVisiblePages: 5
  }
};

// ========================================
// SELECTORES COMUNES PARA OPTIMIZACI√ìN
// ========================================

/**
 * Selectores CSS optimizados para el dashboard
 * @type {Object}
 * @namespace SELECTORS
 * @description Selectores CSS reutilizables para optimizar el rendimiento
 */
const SELECTORS = {
  /**
   * Selectores base para tarjetas de estad√≠sticas
   * @type {Object}
   * @property {string} STAT_CARD - Selector de tarjeta de estad√≠stica
   * @property {string} STAT_VALUE - Selector de valor de estad√≠stica
   * @property {string} STAT_DESC - Selector de descripci√≥n de estad√≠stica
   */
  // Selectores base
  STAT_CARD: '.mi-integracion-api-stat-card',
  STAT_VALUE: '.mi-integracion-api-stat-value',
  STAT_DESC: '.mi-integracion-api-stat-desc',
  
  /**
   * Selectores espec√≠ficos por tipo de tarjeta
   * @type {Object}
   * @property {string} STAT_CARD_MEMORY - Selector de tarjeta de memoria
   * @property {string} STAT_CARD_RETRIES - Selector de tarjeta de reintentos
   * @property {string} STAT_CARD_SYNC - Selector de tarjeta de sincronizaci√≥n
   */
  // Selectores espec√≠ficos
  STAT_CARD_MEMORY: '.mi-integracion-api-stat-card.memory',
  STAT_CARD_RETRIES: '.mi-integracion-api-stat-card.retries',
  STAT_CARD_SYNC: '.mi-integracion-api-stat-card.sync',
  
  /**
   * Selectores compuestos para compatibilidad
   * @type {Object}
   * @property {string} DASHBOARD_CARDS - Selector compuesto de tarjetas
   * @property {string} METRIC_ELEMENTS - Selector compuesto de elementos de m√©tricas
   */
  // Selectores compuestos (mantener flexibilidad)
  DASHBOARD_CARDS: '.dashboard-card, .verial-stat-card, .mi-integracion-api-stat-card',
  METRIC_ELEMENTS: '.dashboard-metric, .verial-stat-value, .mi-integracion-api-stat-value'
};

// ========================================
// CLASE ERRORHANDLER GLOBAL
// ========================================
/**
 * ========================================
 * ERROR HANDLER - MANEJO CENTRALIZADO DE ERRORES
 * ========================================
 * 
 * @class ErrorHandler
 * @description Gesti√≥n centralizada de errores y notificaciones UI
 * @namespace ErrorHandler
 * 
 * @example
 * // Uso b√°sico
 * ErrorHandler.logError('Error message', 'CONTEXT');
 * ErrorHandler.showUIError('Error message', 'error');
 * 
 * @since 1.0.0
 * @author Christian
 */
class ErrorHandler {
  
  /**
   * Logging b√°sico para debugging
   * @static
   * @param {string} message - El mensaje de error
   * @param {string|null} [context=null] - El contexto del error (opcional)
   * @returns {void}
   * @example
   * ErrorHandler.logError('Error de conexi√≥n', 'AJAX');
   */
  static logError(message, context = null) {
    const timestamp = new Date().toISOString();
    const contextStr = context ? ` [${context}]` : '';
    console.error(`[${timestamp}]${contextStr} ${message}`);
  }
  
  /**
   * Muestra un error en la interfaz de usuario
   * @static
   * @param {string} message - El mensaje de error
   * @param {string} [type='error'] - El tipo de error ('error' o 'warning')
   * @returns {void}
   * @example
   * ErrorHandler.showUIError('Error de conexi√≥n', 'error');
   * ErrorHandler.showUIError('Advertencia', 'warning');
   */
  static showUIError(message, type = 'error') {
    const $feedback = jQuery(DASHBOARD_CONFIG.selectors.feedback);
    
    if (!$feedback.length) {
      // Fallback: mostrar en consola y crear elemento temporal
      console.error('No se encontr√≥ elemento de feedback, usando fallback');
      console.error(`Error: ${message}`);
      
      // Crear elemento temporal si no existe
      const $tempFeedback = jQuery('<div id=\'mi-sync-feedback\' class=\'mi-api-feedback\'></div>')
        .appendTo('body')
        .css({
          position: 'fixed',
          top: '20px',
          right: '20px',
          zIndex: 9999,
          padding: '10px',
          backgroundColor: type === 'error' ? '#f8d7da' : '#fff3cd',
          border: `1px solid ${type === 'error' ? '#f5c6cb' : '#ffeaa7'}`,
          borderRadius: '4px',
          maxWidth: '300px'
        });
      
      const errorClass = type === 'error' ? 'mi-api-error' : 'mi-api-warning';
      const icon = type === 'error' ? '‚ùå' : '‚ö†Ô∏è';
      
      $tempFeedback.html(`<div class="${errorClass}"><strong>${icon}:</strong> ${message}</div>`);
      
      // Auto-ocultar despu√©s de 5 segundos
      setTimeout(() => $tempFeedback.fadeOut(500, () => $tempFeedback.remove()), 5000);
      return;
    }
    
    const errorClass = type === 'error' ? 'mi-api-error' : 'mi-api-warning';
    const icon = type === 'error' ? '‚ùå' : '‚ö†Ô∏è';
    
    $feedback.removeClass('in-progress').html(
      `<div class="${errorClass}"><strong>${icon}:</strong> ${message}</div>`
    );
  }
  
  /**
   * Muestra un error de conexi√≥n b√°sico
   * @static
   * @param {Object} xhr - El objeto XMLHttpRequest
   * @returns {void}
   * @example
   * ErrorHandler.showConnectionError(xhr);
   */
  static showConnectionError(xhr) {
    let status = 'Error';
    let message;
    
    if (xhr) {
      if (xhr.status) {
        status = xhr.status;
      } else if (xhr.statusText) {
        status = xhr.statusText;
      }
      
      // Manejar casos espec√≠ficos
      if (xhr.status === 0) {
        message = 'Error de conexi√≥n: No se pudo conectar al servidor';
      } else if (xhr.status === 403) {
        message = 'Error de permisos: Acceso denegado';
      } else if (xhr.status === 404) {
        message = 'Error: Recurso no encontrado';
      } else if (xhr.status === 500) {
        message = 'Error del servidor: Problema interno';
      } else {
        message = `Error de conexi√≥n (${status})`;
      }
    } else {
      message = 'Error de conexi√≥n: No se pudo establecer comunicaci√≥n';
    }
    
    this.showUIError(message);
  }
  
  /**
   * Muestra un error de protecci√≥n
   * @static
   * @param {string} reason - La raz√≥n de la protecci√≥n
   * @returns {void}
   * @example
   * ErrorHandler.showProtectionError('Click autom√°tico detectado');
   */
  static showProtectionError(reason) {
    this.logError(`Protecci√≥n activada: ${reason}`);
    // No mostrar en UI para evitar spam
  }
  
  /**
   * Muestra un error de cancelaci√≥n
   * @static
   * @param {string} message - El mensaje de error de cancelaci√≥n
   * @param {string} [context='CANCEL'] - El contexto de la cancelaci√≥n (opcional)
   * @returns {void}
   * @example
   * ErrorHandler.showCancelError('Error al cancelar sincronizaci√≥n');
   */
  static showCancelError(message, context = 'CANCEL') {
    this.logError(`Error de cancelaci√≥n: ${message}`, context);
    this.showUIError(`Error al cancelar: ${message}`, 'error');
  }
  
  /**
   * Muestra un error cr√≠tico
   * @static
   * @param {string} message - El mensaje de error
   * @param {string} [context='CRITICAL'] - El contexto del error cr√≠tico (opcional)
   * @returns {void}
   * @example
   * ErrorHandler.showCriticalError('Error cr√≠tico del sistema');
   */
  static showCriticalError(message, context = 'CRITICAL') {
    this.logError(`Error cr√≠tico: ${message}`, context);
    this.showUIError(`Error cr√≠tico: ${message}`, 'error');
  }
  
}

/**
 * - Inicializaci√≥n principal
 * - Limpieza autom√°tica
 * - Animaciones y efectos
 */
jQuery(document).ready(function($) {
  // ========================================
  // SECCI√ìN 1: INICIALIZACI√ìN PRINCIPAL
  // ======================================== 
  
  // Selector compuesto para compatibilidad
  const dashboardSelector = '.mi-integracion-api-dashboard, .verial-dashboard';
  
  // Configurar renovaci√≥n peri√≥dica de nonce cada 30 minutos
  setInterval(function() {
    attemptNonceRenewal();
  }, 30 * 60 * 1000); // 30 minutos
  
  /**
   * ========================================
   * AJAX MANAGER - GESTI√ìN CENTRALIZADA DE PETICIONES AJAX
   * ========================================
   * 
   * @class AjaxManager
   * @description Wrapper centralizado para todas las peticiones AJAX del dashboard
   * @namespace AjaxManager
   * 
   * @example
   * // Uso b√°sico
   * AjaxManager.call('action', data, successCallback, errorCallback);
   * 
   * @since 1.0.0
   * @author Christian
   */
  window.AjaxManager = class AjaxManager {
    /**
     * Wrapper b√°sico de jQuery.ajax
     * @static
     * @param {string} action - Acci√≥n a ejecutar
     * @param {Object} [data={}] - Datos adicionales a enviar
     * @param {Function} [success=null] - Callback de √©xito
     * @param {Function} [error=null] - Callback de error
     * @param {Object} [options={}] - Opciones adicionales de jQuery.ajax
     * @returns {jQuery.Deferred} Objeto jQuery Deferred/Promise
     * @example
     * AjaxManager.call('mia_get_sync_progress', {}, 
     *   function(response) { console.log(response); },
     *   function(xhr, status, error) { console.error(error); }
     * );
     */
    static call(action, data = {}, success = null, error = null, options = {}) {
      // Verificar que ajaxurl y nonce est√©n disponibles
      if (!miIntegracionApiDashboard || !miIntegracionApiDashboard.ajaxurl || !miIntegracionApiDashboard.nonce) {
        console.error('miIntegracionApiDashboard, ajaxurl o nonce no est√°n disponibles');
        console.error('miIntegracionApiDashboard:', typeof miIntegracionApiDashboard);
        if (error) {
          error(null, 'error', 'Configuraci√≥n AJAX incompleta - Variables no disponibles');
        }
        // Retornar una promesa jQuery rechazada para mantener el tipo de retorno
        return jQuery.Deferred().reject(null, 'error', 'Configuraci√≥n AJAX incompleta - Variables no disponibles').promise();
      }
      
      // SIMPLE: Solo wrapper b√°sico de jQuery.ajax
      const ajaxOptions = {
        url: miIntegracionApiDashboard.ajaxurl,
        type: 'POST',
        data: Object.assign({
          action,
          nonce: miIntegracionApiDashboard.nonce
        }, data),
        success,
        error
      };
      
      // Aplicar opciones adicionales si existen
      if (options) {
        Object.assign(ajaxOptions, options);
      }
      
      return jQuery.ajax(ajaxOptions);
    }
  };
  
  // Hacer ErrorHandler disponible globalmente
  window.ErrorHandler = ErrorHandler;
  
  /**
   * Recarga de m√©tricas v√≠a AJAX
   * 
   * Maneja la recarga de m√©tricas del dashboard mediante peticiones AJAX.
   * Versi√≥n simplificada y corregida para evitar problemas de compatibilidad.
   * 
   * @function reloadMetrics
   * @param {Event} e - Evento de click del bot√≥n
   * @returns {void}
   * @since 1.0.0
   * @example
   * // Se ejecuta autom√°ticamente al hacer click en el bot√≥n de recarga
   * jQuery('.reload-metrics').on('click', reloadMetrics);
   */
  jQuery(dashboardSelector + ' .reload-metrics').on('click', function(e) {
    e.preventDefault();
    const $btn = jQuery(this);
    $btn.prop('disabled', true);
    

    
    // Validaciones M√çNIMAS - sin alerts que bloqueen
    if (typeof ajaxurl === 'undefined') {
      ErrorHandler.showUIError('ajaxurl no est√° disponible', 'error');
      $btn.prop('disabled', false);
      return;
    }
    
    if (typeof miIntegracionApiDashboard === 'undefined' || !miIntegracionApiDashboard.nonce) {
      ErrorHandler.showUIError('Configuraci√≥n de nonce no disponible', 'error');
      $btn.prop('disabled', false);
      return;
    }
    
    // PETICI√ìN AJAX SIMPLE - usando AjaxManager
    AjaxManager.call('mi_integracion_api_reload_metrics', {}, 
      function(response) {
        if (response.success) {
          // Actualizar elementos de la UI usando cache DOM
          if (response.data) {
            // Actualizar m√©tricas si est√°n disponibles
            if (response.data.total_processed !== undefined) {
              let metricText = `${response.data.total_processed} productos procesados`;
              if (response.data.total_batches !== undefined) {
                metricText += ` en ${response.data.total_batches} lotes`;
              }
              DOM_CACHE.$metricElements.text(metricText);
            }
            // Actualizar otros campos de datos si est√°n disponibles
            if (response.data.data && typeof response.data.data === 'object') {
              // Datos adicionales disponibles pero no procesados
            }
          }
        } else {
          ErrorHandler.logError('Respuesta no exitosa', 'SYNC_START');
        }
      },
      null, // Usar manejo de errores por defecto
      {
        complete() {
          $btn.prop('disabled', false);
        }
      }
    );
  });

  // OPTIMIZACI√ìN: Cachear selector compuesto para tooltips
  const $dashboardCards = jQuery(dashboardSelector + ' .dashboard-card, ' + dashboardSelector + ' .verial-stat-card, ' + dashboardSelector + ' .mi-integracion-api-stat-card');
  $dashboardCards.hover(function() {
    jQuery(this).addClass('hovered');
  }, function() {
    jQuery(this).removeClass('hovered');
  });
  
  // --- Sincronizaci√≥n masiva de productos ---
  // OPTIMIZACI√ìN: Cachear elementos DOM para evitar consultas repetitivas
  
  const DOM_CACHE = {
    $syncBtn: jQuery(DASHBOARD_CONFIG.selectors.syncButton),
    $feedback: jQuery(DASHBOARD_CONFIG.selectors.feedback),
    $progressBar: jQuery('.sync-progress-bar'),
    $progressInfo: jQuery(DASHBOARD_CONFIG.selectors.progressInfo),
    $cancelBtn: jQuery(DASHBOARD_CONFIG.selectors.cancelButton),
    $syncStatusContainer: jQuery(DASHBOARD_CONFIG.selectors.statusContainer),
    $batchSizeSelector: jQuery(DASHBOARD_CONFIG.selectors.batchSize),
    $metricElements: jQuery('.dashboard-metric:not(.mi-integracion-api-stat-card):not([data-card-type])')
  };
  
  let syncInterval = null;

  // Log de depuraci√≥n para verificar objeto localizado
  if (typeof miIntegracionApiDashboard === 'undefined') {
    ErrorHandler.logError('miIntegracionApiDashboard no est√° definido', 'INIT');
  } else {
    // miIntegracionApiDashboard est√° disponible, continuar con la inicializaci√≥n
  }

  // ========================================
  // SISTEMA DE POLLING UNIFICADO
  // ========================================
  
  /**
   * Clase para gestionar todos los sistemas de polling de forma unificada
   * @class PollingManager
   * @description Gesti√≥n unificada de sistemas de polling del dashboard
   * @namespace PollingManager
   * 
   * @example
   * // Crear instancia
   * const pollingManager = new PollingManager();
   * 
   * // Iniciar polling
   * pollingManager.startPolling('syncProgress', callback, 30000);
   * 
   * // Detener polling
   * pollingManager.stopPolling('syncProgress');
   * 
   * @since 1.0.0
   * @author Christian
   */
  class PollingManager {
    /**
     * Constructor de PollingManager
     * @constructor
     * @description Inicializa el gestor de polling con configuraci√≥n desde PHP
     */
    constructor() {
      this.intervals = new Map();
      
      // CENTRALIZADO: Solo usar configuraci√≥n de PHP - sin fallbacks hardcodeados
      const phpConfig = (typeof miIntegracionApiDashboard !== 'undefined' && miIntegracionApiDashboard.pollingConfig) 
        ? miIntegracionApiDashboard.pollingConfig 
        : {}; // Si no hay config PHP, ser√° problema del servidor
      
      this.config = {
        intervals: phpConfig.intervals || {
          normal: 15000,    // 15 segundos - modo normal
          active: 5000,     // 5 segundos - modo activo (sincronizaci√≥n en progreso)
          fast: 2000,       // 2 segundos - modo r√°pido (progreso activo)
          slow: 45000,      // 45 segundos - modo lento (sin actividad)
          idle: 120000      // 2 minutos - modo inactivo
        },
        thresholds: phpConfig.thresholds || {
          to_slow: 3,
          to_idle: 8,
          max_errors: 5,
          progress_threshold: 0.1  // Cambio m√≠nimo de progreso para considerar activo
        },
        currentInterval: (phpConfig.intervals && phpConfig.intervals.normal) || 10000,
        currentMode: 'normal',
        errorCount: 0,
        lastProgress: 0,
        progressStagnantCount: 0
      };
      this.counters = {
        inactive: 0,
        lastProgress: 0
      };
    }
    
    /**
     * Iniciar polling con nombre espec√≠fico
     * @param {string} name - Nombre √∫nico del polling
     * @param {Function} callback - Funci√≥n a ejecutar en cada intervalo
     * @param {number|null} [interval=null] - Intervalo en milisegundos (usa configuraci√≥n por defecto si es null)
     * @returns {number} ID del intervalo creado
     * @example
     * pollingManager.startPolling('syncProgress', checkSyncProgress, 30000);
     */
    startPolling(name, callback, interval = null) {
      this.stopPolling(name);
      
      const actualInterval = interval || this.config.currentInterval;
      const intervalId = setInterval(callback, actualInterval);
      
      this.intervals.set(name, {
        id: intervalId,
        callback,
        interval: actualInterval,
        startTime: Date.now()
      });
      
      return intervalId;
    }
    
    /**
     * Detener polling espec√≠fico
     * @param {string} name - Nombre del polling a detener
     * @returns {boolean} true si se detuvo correctamente, false si no exist√≠a
     * @example
     * pollingManager.stopPolling('syncProgress');
     */
    stopPolling(name) {
      if (this.intervals.has(name)) {
        const polling = this.intervals.get(name);
        clearInterval(polling.id);
        this.intervals.delete(name);
        return true;
      }
      return false;
    }
    
    /**
     * Detener todos los polling
     * @returns {void}
     * @example
     * pollingManager.stopAllPolling();
     */
    stopAllPolling() {
      this.intervals.forEach((polling) => {
        clearInterval(polling.id);
      });
      this.intervals.clear();
    }
    
    /**
     * Verificar si hay polling activo
     * @param {string|null} [name=null] - Nombre espec√≠fico del polling a verificar (opcional)
     * @returns {boolean} true si hay polling activo, false en caso contrario
     * @example
     * // Verificar si hay alg√∫n polling activo
     * pollingManager.isPollingActive();
     * 
     * // Verificar polling espec√≠fico
     * pollingManager.isPollingActive('syncProgress');
     */
    isPollingActive(name = null) {
      if (name) {
        return this.intervals.has(name);
      }
      return this.intervals.size > 0;
    }      
    
    /**
     * Ajusta el polling adaptativamente basado en el progreso
     * @param {number} currentProgress Progreso actual (0-100)
     * @param {boolean} isActive Si la sincronizaci√≥n est√° activa
     * @returns {void}
     * @example
     * pollingManager.adjustPolling(75, true);
     */
    adjustPolling(currentProgress, isActive) {
      if (!isActive) {
        this.config.currentMode = 'idle';
        this.config.currentInterval = this.config.intervals.idle;
        return;
      }

      const progressChange = Math.abs(currentProgress - this.config.lastProgress);
      const threshold = this.config.thresholds.progress_threshold;

      // ‚úÖ OPTIMIZACI√ìN: L√≥gica m√°s conservadora para reducir peticiones
      if (progressChange > threshold) {
        // Progreso activo - usar modo r√°pido solo si el cambio es significativo
        if (progressChange > 5) { // Cambio de m√°s del 5%
          this.config.currentMode = 'fast';
          this.config.currentInterval = this.config.intervals.fast;
        } else {
          // Cambio peque√±o - mantener modo activo
          this.config.currentMode = 'active';
          this.config.currentInterval = this.config.intervals.active;
        }
        this.config.progressStagnantCount = 0;
      } else {
        // Progreso estancado - incrementar contador
        this.config.progressStagnantCount++;
        
        if (this.config.progressStagnantCount >= 5) { // Aumentado de 3 a 5
          // Progreso estancado por 5 ciclos - usar modo lento
          this.config.currentMode = 'slow';
          this.config.currentInterval = this.config.intervals.slow;
        } else if (this.config.progressStagnantCount >= 2) {
          // Despu√©s de 2 ciclos sin progreso - usar modo normal
          this.config.currentMode = 'normal';
          this.config.currentInterval = this.config.intervals.normal;
        } else {
          // Mantener modo activo normal
          this.config.currentMode = 'active';
          this.config.currentInterval = this.config.intervals.active;
        }
      }

      this.config.lastProgress = currentProgress;
    }

    /**
     * Resetear configuraci√≥n
     * @returns {void}
     * @example
     * pollingManager.reset();
     */
    reset() {
      this.stopAllPolling();
      this.config.currentInterval = this.config.intervals.normal;
      this.config.currentMode = 'normal';
      this.config.errorCount = 0;
      this.config.lastProgress = 0;
      this.config.progressStagnantCount = 0;
      this.counters.inactive = 0;
      this.counters.lastProgress = 0;
    }
  }
  
  // Instancia global del PollingManager
  const pollingManager = new PollingManager();
  
  // ========================================
  // SISTEMA DE MANEJO DE ERRORES DE PROGRESO
  // ========================================
  
  /**
   * Determina el tipo de error basado en la respuesta AJAX
   * @param {Object} xhr - Objeto XMLHttpRequest
   * @param {string} status - Estado de la petici√≥n
   * @param {string} error - Mensaje de error
   * @returns {string} Tipo de error
   */
  function getProgressErrorType(xhr, status, error) {
    if (!navigator.onLine) return 'offline';
    if (xhr && xhr.status === 403) return 'auth';
    if (xhr && xhr.status === 404) return 'not_found';
    if (xhr && xhr.status === 500) return 'server';
    if (xhr && xhr.status === 0) return 'timeout';
    if (status === 'timeout') return 'timeout';
    if (status === 'abort') return 'cancelled';
    return 'unknown';
  }
  
  /**
   * Genera mensaje de error espec√≠fico para progreso
   * @param {string} errorType - Tipo de error
   * @param {Object} xhr - Objeto XMLHttpRequest
   * @param {string} status - Estado de la petici√≥n
   * @param {string} error - Mensaje de error
   * @returns {string} Mensaje de error espec√≠fico
   */
  function getProgressErrorMessage(errorType, xhr, status, error) {
    const messages = {
      offline: 'Sin conexi√≥n a internet. Verificando progreso...',
      auth: 'Sesi√≥n expirada. Recargando p√°gina...',
      not_found: 'Endpoint de progreso no encontrado',
      server: 'Error del servidor. Reintentando...',
      timeout: 'Timeout de conexi√≥n. Reintentando...',
      cancelled: 'Verificaci√≥n de progreso cancelada',
      unknown: `Error desconocido: ${error || status}`
    };
    return messages[errorType] || messages.unknown;
  }
  
  /**
   * Muestra error espec√≠fico para progreso
   * @param {string} message - Mensaje de error
   * @param {string} errorType - Tipo de error
   */
  function showProgressError(message, errorType) {
    const isRetryable = ['timeout', 'server', 'offline'].includes(errorType);
    const icon = isRetryable ? 'üîÑ' : '‚ùå';
    
    DOM_CACHE.$progressInfo.html(`${icon} ${message}`);
    
    if (errorType === 'auth') {
      setTimeout(() => window.location.reload(), 2000);
    }
  }
  
  /**
   * Ajusta el polling basado en el tipo de error
   * @param {string} errorType - Tipo de error
   */
  function adjustPollingOnError(errorType) {
    const retryableErrors = ['timeout', 'server', 'offline'];
    
    if (retryableErrors.includes(errorType)) {
      // Aumentar intervalo para errores recuperables
      pollingManager.config.currentInterval = Math.min(
        pollingManager.config.currentInterval * 1.5,
        pollingManager.config.intervals.slow
      );
    } else if (errorType === 'auth') {
      // Detener polling para errores de autenticaci√≥n
      pollingManager.stopPolling('syncProgress');
    }
  }
  
  // ========================================
  // SISTEMA DE MANEJO DE ERRORES UNIFICADO
  // ========================================
  
  // ErrorHandler ya est√° definido globalmente arriba
  
  // Variables de compatibilidad (para no romper c√≥digo existente)
  let inactiveProgressCounter = 0;
  let lastProgressValue = 0;
  
  // Funciones de compatibilidad
  function stopProgressPolling() {
    // El par√°metro 'reason' solo sirve para logging y diagn√≥stico.
    // No afecta la l√≥gica de la funci√≥n ni el estado del sistema.
    // Se puede eliminar porque no se utiliza para modificar el comportamiento,
    // y el motivo puede registrarse directamente en el log si es necesario.
    pollingManager.stopAllPolling();
    // Estado manejado por PHP - no necesario marcar en JavaScript
  }
  
  function isPollingActive() {
    return pollingManager.isPollingActive();
  }
  
  // CORRECCI√ìN: Funci√≥n de limpieza al cargar la p√°gina
  function cleanupOnPageLoad() {
    // Detener cualquier polling activo al cargar la p√°gina
    if (isPollingActive()) {
      stopProgressPolling('Limpieza al cargar p√°gina');
    }
    
    // Resetear contadores
    inactiveProgressCounter = 0;
    lastProgressValue = 0;
    
    // Resetear configuraci√≥n de polling
    pollingManager.config.currentInterval = pollingManager.config.intervals.normal;
    pollingManager.config.currentMode = 'normal';
    pollingManager.config.errorCount = 0;
  }
  
  // ========================================
  // SECCI√ìN 2: LIMPIEZA AUTOM√ÅTICA
  // ========================================
  
  // CORRECCI√ìN: Ejecutar limpieza al cargar la p√°gina (CONSOLIDADO)
  cleanupOnPageLoad();  
  
  /**
   * Verifica el progreso de la sincronizaci√≥n
   * 
   * Realiza una petici√≥n AJAX para verificar el estado actual de la
   * sincronizaci√≥n y actualiza la interfaz de usuario en consecuencia.
   * Utiliza un sistema de polling adaptativo para monitorear el progreso.
   * 
   * IMPORTANTE: Esta funci√≥n SOLO monitorea el progreso, NO procesa lotes.
   * El backend maneja autom√°ticamente el procesamiento de todos los lotes.
   * 
   * @function checkSyncProgress
   * @description Verifica el progreso de sincronizaci√≥n v√≠a AJAX (solo monitoreo)
   * @returns {void}
   * @since 1.0.0
   * @example
   * // Se ejecuta autom√°ticamente por el sistema de polling
   * checkSyncProgress();
   */
  function checkSyncProgress() {
    // Iniciando llamada AJAX para verificar progreso
    console.log('üîç checkSyncProgress() ejecut√°ndose...', {
      timestamp: new Date().toISOString(),
      lastKnownBatch: checkSyncProgress.lastKnownBatch || 0,
      lastKnownItemsSynced: checkSyncProgress.lastKnownItemsSynced || 0
    });
    
    // Variables para detectar cambios en tiempo real
    if (typeof checkSyncProgress.lastKnownBatch === 'undefined') {
      checkSyncProgress.lastKnownBatch = 0;
      checkSyncProgress.lastKnownItemsSynced = 0;
      checkSyncProgress.lastKnownTotalBatches = 0;
      checkSyncProgress.lastKnownTotalItems = 0;
    }
    
    jQuery.ajax({
      url: ajaxurl,
      type: 'POST',
      timeout: (DASHBOARD_CONFIG && DASHBOARD_CONFIG.timeouts && DASHBOARD_CONFIG.timeouts.ajax) ? DASHBOARD_CONFIG.timeouts.ajax * 2 : 120000, // Timeout para verificaci√≥n de progreso
      data: {
        action: 'mia_get_sync_progress',
        nonce: miIntegracionApiDashboard.nonce
      },
      success(response) {
        // Procesando respuesta de progreso
        
        // VERIFICACI√ìN: Solo procesar respuestas del endpoint mia_get_sync_progress
        if (!response.data) {
          return;
        }
        
        // Verificar si hay estad√≠sticas disponibles
        let estadisticas = response.data.estadisticas || response.data.stats || response.data || {};
        
        // CORRECCI√ìN: Declarar variables al inicio para evitar errores de referencia
        let porcentaje = 0;
        let mensaje = '';
        let syncMeta = {};
        
        // Mostrar headers y status completo para diagn√≥stico
        if (response.success) {
          if (response.data) {
            // CORRECCI√ìN: Usar estructura flexible para diferentes endpoints
            porcentaje = response.data.porcentaje || response.data.progress || 0;
            mensaje = response.data.mensaje || response.data.message || response.data.status || 'Procesando...';

            // Manejar estad√≠sticas de forma flexible
            const statsData = response.data.estadisticas || response.data.stats || response.data;
            estadisticas = {
              procesados: statsData.procesados || statsData.processed || statsData.completed || 0,
              total: statsData.total || statsData.total_items || statsData.items || 0,
              errores: statsData.errores || statsData.errors || statsData.failed || 0
            };

            syncMeta = {
              in_progress: response.data.in_progress !== false,  // M√°s flexible para diferentes valores
              current_batch: response.data.current_batch || response.data.batch || response.data.current || 0,
              total_batches: response.data.total_batches || response.data.total || 1
            };


            // DETECCI√ìN DE CAMBIOS: Verificar si cambi√≥ el lote actual o los items procesados
            const batchChanged = syncMeta.current_batch !== checkSyncProgress.lastKnownBatch;
            const itemsChanged = estadisticas.procesados !== checkSyncProgress.lastKnownItemsSynced;
            const totalBatchesChanged = syncMeta.total_batches !== checkSyncProgress.lastKnownTotalBatches;
            const totalItemsChanged = estadisticas.total !== checkSyncProgress.lastKnownTotalItems;
            
            // CORRECCI√ìN: Si el lote cambi√≥ pero items_synced no, calcular el valor esperado
            if (batchChanged && !itemsChanged && syncMeta.current_batch > checkSyncProgress.lastKnownBatch) {
              // Calcular items_synced esperado basado en el lote actual
              const expectedItemsSynced = syncMeta.current_batch * 50; // 50 productos por lote
              if (expectedItemsSynced > checkSyncProgress.lastKnownItemsSynced) {
                estadisticas.procesados = expectedItemsSynced;
                console.log('üîß CORRECCI√ìN: Calculando items_synced esperado', {
                  current_batch: syncMeta.current_batch,
                  lastKnownBatch: checkSyncProgress.lastKnownBatch,
                  lastKnownItemsSynced: checkSyncProgress.lastKnownItemsSynced,
                  expectedItemsSynced,
                  correctedItemsSynced: estadisticas.procesados
                });
              }
            }
            
            const hasSignificantChange = batchChanged || itemsChanged || totalBatchesChanged || totalItemsChanged;
                  

                  // SIMPLIFICADO: Solo usar mensaje del servidor - no modificar l√≥gica de negocio
                  // PHP ya env√≠a el mensaje correcto procesado

                  // Mostrar informaci√≥n de polling en modo debug si est√° habilitado
                  // COMENTADO: getPollingStats() no est√° definida - causa error
                  // if (typeof miIntegracionApiDashboard !== 'undefined' && miIntegracionApiDashboard.debug) {
                  //   var stats = getPollingStats();
                  //   mensaje += ` [Polling: ${stats.mode}, ${stats.efficiency.requestsPerMinute} req/min]`;
                  // }

                  // Asegurar que el contenedor de progreso es visible
            DOM_CACHE.$syncStatusContainer.css('display', 'block');

            // MEJORADO: Mostrar progreso detallado por lotes
            const productosProcesados = estadisticas.procesados || 0;
            const totalProductos = estadisticas.total || 0;
            const loteActual = syncMeta.current_batch || 0;
            const totalLotes = syncMeta.total_batches || 1;

            // Usar datos calculados por el backend para consistencia
            const anchoActual = response.data.progress_width || '2%';
            const porcentajeVisual = response.data.porcentaje_visual || 0;

            // Actualizar barra de progreso
            DOM_CACHE.$progressBar.css('width', anchoActual);
            
            // ‚úÖ NUEVO: Ajustar polling adaptativamente basado en el progreso
            const isActive = response.data.in_progress || false;
            pollingManager.adjustPolling(porcentajeVisual, isActive);
            
            // ‚úÖ NUEVO: Mostrar progreso de ambas fases (Fase 1: im√°genes, Fase 2: productos)
            const phase1Status = response.data.phase1_images || {};
            const phase1InProgress = phase1Status.in_progress || false;
            const phase1Completed = phase1Status.completed || false;
            const phase1ProductsProcessed = phase1Status.products_processed || 0;
            const phase1TotalProducts = phase1Status.total_products || 0;
            const phase1ImagesProcessed = phase1Status.images_processed || 0;
            
            // ‚úÖ NUEVO: Actualizar terminal de consola
            updateSyncConsole(response.data, phase1Status);
            
            // ‚úÖ NUEVO: Actualizar dashboard de dos fases
            if (window.syncDashboard) {
              window.syncDashboard.updatePhase1Progress(phase1Status);
              if (response.data && response.data.estadisticas) {
                window.syncDashboard.updatePhase2Progress(response.data);
              }
            }
            
            // Crear mensaje detallado de progreso por lotes usando datos del backend
            let progresoTexto = '';
            
            // Si Fase 1 est√° en progreso, mostrar su progreso
            if (phase1InProgress && !phase1Completed) {
              const phase1Percent = phase1TotalProducts > 0 ? ((phase1ProductsProcessed / phase1TotalProducts) * 100).toFixed(1) : 0;
              progresoTexto = `Fase 1 (Im√°genes): ${phase1ProductsProcessed}/${phase1TotalProducts} productos, ${phase1ImagesProcessed} im√°genes (${phase1Percent}%)`;
            } else if (phase1Completed) {
              // Fase 1 completada, mostrar Fase 2
              if (totalProductos > 0) {
                if (totalLotes > 1) {
                  // Mostrar informaci√≥n de lotes: "Lote X de Y - Z/W productos (P%)"
                  progresoTexto = `Fase 2 (Productos): Lote ${loteActual} de ${totalLotes} - ${productosProcesados}/${totalProductos} productos (${porcentajeVisual.toFixed(1)}%)`;
                } else {
                  // Solo un lote: "Z/W productos (P%)"
                  progresoTexto = `Fase 2 (Productos): ${productosProcesados}/${totalProductos} productos (${porcentajeVisual.toFixed(1)}%)`;
                }
              } else {
                progresoTexto = `Fase 2 (Productos): ${productosProcesados}/${totalProductos} productos (${porcentajeVisual.toFixed(1)}%)`;
              }
            } else {
              // Fase 1 no iniciada o Fase 2 en progreso sin Fase 1
              if (totalProductos > 0) {
                if (totalLotes > 1) {
                  progresoTexto = ` - Lote ${loteActual} de ${totalLotes} - ${productosProcesados}/${totalProductos} productos (${porcentajeVisual.toFixed(1)}%)`;
                } else {
                  progresoTexto = ` - ${productosProcesados}/${totalProductos} productos (${porcentajeVisual.toFixed(1)}%)`;
                }
              }
            }
                  
            DOM_CACHE.$progressInfo.text(mensaje + progresoTexto);

                  // ACTUALIZAR VARIABLES DE SEGUIMIENTO si hay cambios significativos
            if (hasSignificantChange) {
                      
              // Actualizar variables de seguimiento
              checkSyncProgress.lastKnownBatch = syncMeta.current_batch;
              checkSyncProgress.lastKnownItemsSynced = estadisticas.procesados;
              checkSyncProgress.lastKnownTotalBatches = syncMeta.total_batches;
              checkSyncProgress.lastKnownTotalItems = estadisticas.total;
                      
                      // Log espec√≠fico de cambios
              if (batchChanged) {
                // Lote cambiado - actualizar seguimiento
              }
              if (itemsChanged) {
                // Items procesados cambiados - actualizar seguimiento
              }
            }

            if (porcentaje !== lastProgressValue) {
              lastProgressValue = porcentaje;
            }

                  // Solo verificar estado y actualizar UI - NO procesar lotes
            if (syncMeta.in_progress) {
              const batchesDone = syncMeta.current_batch;
              const totalBatches = syncMeta.total_batches;

                      // Mostrar informaci√≥n de progreso de lotes
              if (totalBatches > 1) {
                const batchProgress = ` (Lote ${batchesDone}/${totalBatches})`;
                const currentMessage = DOM_CACHE.$progressInfo.text();
                if (!currentMessage.includes('Lote')) {
                  DOM_CACHE.$progressInfo.text(currentMessage + batchProgress);
                }
              }

                      // El backend maneja TODA la secuencia autom√°ticamente

              if (inactiveProgressCounter > 0) {


                if (inactiveProgressCounter >= 20) {
                  DOM_CACHE.$progressInfo.text('Procesando... El backend maneja la continuaci√≥n autom√°ticamente.');
                }
              }
            } else {
              // No hay cambios significativos, continuar con el procesamiento normal
            }

            // Usar campo is_completed calculado por el backend para consistencia
            const isCompleted = response.data.is_completed || false;
                  
                  
            if (isCompleted) {

              stopProgressPolling('Sincronizaci√≥n completada');
              DOM_CACHE.$syncBtn.prop('disabled', false).text(window.originalSyncButtonText || 'Sincronizar productos en lote');
              DOM_CACHE.$batchSizeSelector.prop('disabled', false);
              DOM_CACHE.$feedback.removeClass('in-progress').text('¬°Sincronizaci√≥n completada!');
                      
                      // Resetear variables de seguimiento
              checkSyncProgress.lastKnownBatch = 0;
              checkSyncProgress.lastKnownItemsSynced = 0;
              checkSyncProgress.lastKnownTotalBatches = 0;
              checkSyncProgress.lastKnownTotalItems = 0;
            } else if (syncMeta.in_progress) {
                      // Solo monitorear progreso - el backend maneja la continuaci√≥n autom√°ticamente
                      // No llamar a processNextBatch() - esto causa m√∫ltiples PIDs y race conditions
                      // El backend procesa todos los lotes autom√°ticamente sin intervenci√≥n del frontend
            }
          } else {
                  // SIMPLIFICADO: Solo mostrar error sin l√≥gica compleja de manejo
            DOM_CACHE.$progressInfo.text('Error obteniendo progreso');
          }
        } else {
              // SIMPLIFICADO: Solo mostrar error sin l√≥gica compleja de manejo
          DOM_CACHE.$progressInfo.text('Error obteniendo progreso');
        }
      },
      error(xhr, status, error) {
        ErrorHandler.logError(`Error AJAX al verificar progreso: ${error}`, 'POLLING');
        
        // SIMPLIFICADO: Solo mostrar error de conexi√≥n b√°sico
        ErrorHandler.showConnectionError(xhr);
        
        // SIMPLIFICADO: Solo casos cr√≠ticos que requieren detener polling
        if (!navigator.onLine || (xhr && xhr.status === 403)) {
          clearInterval(syncInterval);
          DOM_CACHE.$syncBtn.prop('disabled', false).text(window.originalSyncButtonText || 'Sincronizar productos en lote');
          DOM_CACHE.$batchSizeSelector.prop('disabled', false);
          return;
        }
        
        // Si es un error de timeout (readyState 0 o status 0 con error vac√≠o), dar un mensaje espec√≠fico
        if ((xhr && xhr.readyState === 0 && xhr.status === 0) || (xhr && xhr.status === 0 && !error)) {
          const errorThreshold = pollingManager.config.thresholds.to_slow || 3;
          if (inactiveProgressCounter > errorThreshold) {
            console.warn(`Posible timeout o servidor sobrecargado (intento ${inactiveProgressCounter})`);
            
            // Solo despu√©s del tercer intento, mostrar mensaje de servicio ocupado
            if (inactiveProgressCounter === errorThreshold + 1) {
              DOM_CACHE.$feedback.removeClass('in-progress').addClass('warning').html(
                '<div class="mi-api-warning"><strong>El servidor est√° tardando en responder</strong><p>La sincronizaci√≥n podr√≠a estar funcionando en segundo plano. ' + 
                'Espere unos minutos o verifique los registros para confirmar el estado.</p></div>'
              );
            }
            
            // Si hay demasiados errores consecutivos, detener la sincronizaci√≥n
            if (inactiveProgressCounter > (pollingManager.config.thresholds.max_errors || 5)) {
              clearInterval(syncInterval);
              DOM_CACHE.$syncBtn.prop('disabled', false).text('Sincronizar productos en lote');
              DOM_CACHE.$batchSizeSelector.prop('disabled', false);
              DOM_CACHE.$feedback.removeClass('in-progress warning').html(
                '<div class="mi-api-error"><strong>Error de comunicaci√≥n:</strong> El servidor no responde despu√©s de varios intentos. ' +
                '<p>La sincronizaci√≥n podr√≠a estar funcionando en segundo plano o haberse detenido. Verifique los registros del sistema.</p>' + 
                '<button id="mi-api-retry-sync" class="button">Reintentar verificaci√≥n</button></div>'
              );
              
              // A√±adir manejador para el bot√≥n de reintento
              $('#mi-api-retry-sync').on('click', function() {
                checkSyncProgress();
                DOM_CACHE.$feedback.addClass('in-progress').text('Verificando estado de la sincronizaci√≥n...');
              });
              
              DOM_CACHE.$syncStatusContainer.hide();
            }
          }
        } else if (inactiveProgressCounter > 3) {
          // Para otros tipos de errores, despu√©s de 3 intentos fallidos
          clearInterval(syncInterval);
          DOM_CACHE.$syncBtn.prop('disabled', false).text('Sincronizar productos en lote');
          DOM_CACHE.$batchSizeSelector.prop('disabled', false);
          DOM_CACHE.$feedback.removeClass('in-progress').html(
            '<div class="mi-api-error"><strong>Error de conexi√≥n:</strong> No se puede verificar el progreso. ' + 
            (xhr.status ? `C√≥digo HTTP: ${xhr.status}` : 'Verifique la conexi√≥n al servidor.') +
            '<p>Intente recargar la p√°gina o esperar unos minutos.</p></div>'
          );
          DOM_CACHE.$syncStatusContainer.hide();
        }
      }
    });
  }


  // Funci√≥n para intentar renovar el nonce autom√°ticamente
  function attemptNonceRenewal() {
    console.log('Intentando renovar nonce autom√°ticamente...');
    
    jQuery.ajax({
      url: ajaxurl,
      type: 'POST',
      data: {
        action: 'mia_renew_nonce'
      },
      success(response) {
        console.log('Respuesta de renovaci√≥n de nonce:', response);
        
        if (response.success && response.data && response.data.nonce) {
          console.log('Nonce renovado exitosamente:', response.data.nonce);
          miIntegracionApiDashboard.nonce = response.data.nonce;
          
          // Mostrar notificaci√≥n de √©xito
          showNotification('Token de seguridad renovado autom√°ticamente', 'success');
        } else {
          console.warn('No se pudo renovar el nonce:', response);
          const errorMessage = (response.data && response.data.message) || 'Error desconocido';
          const errorCode = (response.data && response.data.code) || 'unknown_error';
          showNotification(`No se pudo renovar el token: ${errorMessage} (${errorCode})`, 'warning');
        }
      },
      error(xhr, status, error) {
        console.error('Error AJAX al renovar nonce:', {xhr, status, error});
        
        let errorMessage = 'Error de conexi√≥n';
        if (xhr && xhr.status) {
          errorMessage = `Error ${xhr.status}: ${error || 'Error de conexi√≥n'}`;
        } else if (status === 'timeout') {
          errorMessage = 'Timeout: La petici√≥n tard√≥ demasiado';
        } else if (status === 'error' && !error) {
          errorMessage = 'Error de red: No se pudo conectar al servidor';
        }
        
        showNotification(`Error al renovar el token: ${errorMessage}`, 'error');
      }
    });
  }

  // ‚úÖ NUEVO: Funci√≥n para actualizar el terminal de consola de sincronizaci√≥n
  function updateSyncConsole(syncData, phase1Status) {
    const $console = jQuery('#mia-sync-console');
    const $consoleContent = jQuery('#mia-console-content');
    
    // Mostrar consola si hay sincronizaci√≥n en progreso
    if (syncData.in_progress || (phase1Status && phase1Status.in_progress)) {
      $console.slideDown(300);
    }
    
    // Actualizar indicadores de fase
    const phase1InProgress = phase1Status && phase1Status.in_progress;
    const phase1Completed = phase1Status && phase1Status.completed;
    const phase2InProgress = syncData.in_progress && !phase1InProgress;
    const phase2Completed = syncData.is_completed;
    
    // Actualizar Fase 1
    const $phase1Indicator = jQuery('#mia-phase1-indicator');
    if (phase1Completed) {
      $phase1Indicator.attr('data-status', 'completed');
      $phase1Indicator.find('.mia-phase-status').text('Completada').attr('data-status', 'completed');
    } else if (phase1InProgress) {
      $phase1Indicator.attr('data-status', 'active');
      $phase1Indicator.find('.mia-phase-status').text('En Progreso').attr('data-status', 'active');
    } else {
      $phase1Indicator.attr('data-status', 'pending');
      $phase1Indicator.find('.mia-phase-status').text('Pendiente').attr('data-status', 'pending');
    }
    
    // Actualizar Fase 2
    const $phase2Indicator = jQuery('#mia-phase2-indicator');
    if (phase2Completed) {
      $phase2Indicator.attr('data-status', 'completed');
      $phase2Indicator.find('.mia-phase-status').text('Completada').attr('data-status', 'completed');
    } else if (phase2InProgress) {
      $phase2Indicator.attr('data-status', 'active');
      $phase2Indicator.find('.mia-phase-status').text('En Progreso').attr('data-status', 'active');
    } else {
      $phase2Indicator.attr('data-status', 'pending');
      $phase2Indicator.find('.mia-phase-status').text('Pendiente').attr('data-status', 'pending');
    }
    
    // Agregar l√≠neas de log seg√∫n el estado
    const now = new Date();
    const timeStr = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    
    // Solo agregar logs si hay cambios significativos
    if (phase1InProgress && phase1Status) {
      const phase1Percent = phase1Status.total_products > 0 
        ? ((phase1Status.products_processed / phase1Status.total_products) * 100).toFixed(1) 
        : 0;
      
      // Verificar si ya existe una l√≠nea similar reciente (evitar spam)
      const lastLine = $consoleContent.find('.mia-console-line').last();
      const lastMessage = lastLine.find('.mia-console-message').text();
      const shouldAdd = !lastMessage.includes(`Fase 1: ${phase1Status.products_processed}/${phase1Status.total_products}`);
      
      if (shouldAdd && phase1Status.products_processed > 0) {
        addConsoleLine('phase1', `Fase 1: ${phase1Status.products_processed}/${phase1Status.total_products} productos procesados, ${phase1Status.images_processed || 0} im√°genes sincronizadas (${phase1Percent}%)`);
      }
    }
    
    if (phase2InProgress && syncData.estadisticas) {
      const phase2Percent = syncData.porcentaje || 0;
      const stats = syncData.estadisticas || {};
      
      // Verificar si ya existe una l√≠nea similar reciente
      const lastLine = $consoleContent.find('.mia-console-line').last();
      const lastMessage = lastLine.find('.mia-console-message').text();
      const shouldAdd = !lastMessage.includes(`Fase 2: ${stats.procesados}/${stats.total}`);
      
      if (shouldAdd && stats.procesados > 0) {
        addConsoleLine('phase2', `Fase 2: ${stats.procesados}/${stats.total} productos sincronizados (${phase2Percent.toFixed(1)}%)`);
      }
    }
    
    if (phase1Completed && !phase2InProgress) {
      addConsoleLine('success', 'Fase 1 completada exitosamente. Iniciando Fase 2...');
    }
    
    if (phase2Completed) {
      addConsoleLine('success', 'Sincronizaci√≥n completada exitosamente');
    }
    
    // Auto-scroll al final
    const $consoleBody = jQuery('.mia-console-body');
    $consoleBody.scrollTop($consoleBody[0].scrollHeight);
  }
  
  // ‚úÖ NUEVO: Funci√≥n auxiliar para agregar l√≠neas al terminal
  function addConsoleLine(type, message) {
    const $consoleContent = jQuery('#mia-console-content');
    const now = new Date();
    const timeStr = now.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    
    const labelMap = {
      'info': '[INFO]',
      'success': '[SUCCESS]',
      'warning': '[WARNING]',
      'error': '[ERROR]',
      'phase1': '[FASE 1]',
      'phase2': '[FASE 2]'
    };
    
    const $line = jQuery('<div>')
      .addClass('mia-console-line')
      .addClass(`mia-console-${type}`)
      .html(`
        <span class="mia-console-time">${timeStr}</span>
        <span class="mia-console-label">${labelMap[type] || '[INFO]'}</span>
        <span class="mia-console-message">${message}</span>
      `);
    
    $consoleContent.append($line);
    
    // Limitar a 100 l√≠neas para evitar problemas de rendimiento
    const lines = $consoleContent.find('.mia-console-line');
    if (lines.length > 100) {
      lines.first().remove();
    }
  }
  
  // ‚úÖ NUEVO: Clase SyncDashboard para gestionar el dashboard de dos fases
  class SyncDashboard {
    constructor() {
      this.phase1Timer = null;
      this.phase2Timer = null;
      this.phase1StartTime = null;
      this.phase2StartTime = null;
      this.initializeEventListeners();
      this.loadCurrentStatus();
    }

    initializeEventListeners() {
      // Fase 1
      jQuery('#start-phase1').on('click', () => this.startPhase1());
      jQuery('#pause-phase1').on('click', () => this.pausePhase1());
      jQuery('#resume-phase1').on('click', () => this.resumePhase1());

      // Fase 2
      jQuery('#start-phase2').on('click', () => this.startPhase2());
      jQuery('#pause-phase2').on('click', () => this.pausePhase2());

      // Configuraci√≥n
      jQuery('#batch-size').on('change', (e) => this.updateConfig('batch_size', e.target.value));
      jQuery('#throttle-delay').on('change', (e) => this.updateConfig('throttle_delay', e.target.value));
      jQuery('#auto-retry').on('change', (e) => this.updateConfig('auto_retry', e.target.checked));
    }

    async startPhase1() {
      this.updatePhaseStatus(1, 'running');
      this.disableButton('start-phase1');
      this.enableButton('pause-phase1');
      this.phase1StartTime = Date.now();
      this.startTimer(1);

      addConsoleLine('phase1', 'Iniciando Fase 1: Sincronizaci√≥n de im√°genes...');

      try {
        const batchSize = parseInt(jQuery('#batch-size').val()) || 50;
        const response = await jQuery.ajax({
          url: ajaxurl,
          method: 'POST',
          data: {
            action: 'mia_sync_images',
            nonce: miIntegracionApiDashboard.nonce,
            resume: false,
            batch_size: batchSize
          }
        });

        if (response.success) {
          addConsoleLine('success', 'Fase 1 iniciada correctamente');
          this.handlePhase1Response(response.data);
        } else {
          const errorMsg = (response.data && response.data.message) || 'Error desconocido';
          addConsoleLine('error', 'Error iniciando Fase 1: ' + errorMsg);
          this.updatePhaseStatus(1, 'error');
          this.enableButton('start-phase1');
        }
      } catch (error) {
        addConsoleLine('error', 'Error iniciando Fase 1: ' + (error.message || 'Error de comunicaci√≥n'));
        this.updatePhaseStatus(1, 'error');
        this.enableButton('start-phase1');
      }
    }

    async startPhase2() {
      this.updatePhaseStatus(2, 'running');
      this.disableButton('start-phase2');
      this.phase2StartTime = Date.now();
      this.startTimer(2);

      addConsoleLine('phase2', 'Iniciando Fase 2: Sincronizaci√≥n de productos...');

      try {
        const batchSize = parseInt(jQuery('#batch-size').val()) || 50;
        const response = await jQuery.ajax({
          url: ajaxurl,
          method: 'POST',
          data: {
            action: 'mi_integracion_api_sync_products_batch',
            nonce: miIntegracionApiDashboard.nonce,
            batch_size: batchSize
          }
        });

        if (response.success) {
          addConsoleLine('success', 'Fase 2 iniciada correctamente');
          // Iniciar polling para monitorear Fase 2
          if (typeof pollingManager !== 'undefined') {
            pollingManager.config.currentInterval = pollingManager.config.intervals.active;
            pollingManager.config.currentMode = 'active';
            syncInterval = pollingManager.startPolling('syncProgress', checkSyncProgress, pollingManager.config.currentInterval);
          }
        } else {
          const errorMsg = (response.data && response.data.message) || 'Error desconocido';
          addConsoleLine('error', 'Error iniciando Fase 2: ' + errorMsg);
          this.updatePhaseStatus(2, 'error');
          this.enableButton('start-phase2');
        }
      } catch (error) {
        addConsoleLine('error', 'Error iniciando Fase 2: ' + (error.message || 'Error de comunicaci√≥n'));
        this.updatePhaseStatus(2, 'error');
        this.enableButton('start-phase2');
      }
    }

    updatePhase1Progress(data) {
      const percentage = data.total_products > 0
        ? Math.round((data.products_processed / data.total_products) * 100)
        : 0;

      jQuery('#phase1-progress-fill').css('width', percentage + '%');
      jQuery('#phase1-percentage').text(percentage + '%');
      jQuery('#phase1-progress-text').text(
        `${data.products_processed}/${data.total_products} ${(DASHBOARD_CONFIG && DASHBOARD_CONFIG.messages && DASHBOARD_CONFIG.messages.progress && DASHBOARD_CONFIG.messages.progress.productsProcessed) || 'productos procesados'}`
      );

      // Actualizar estad√≠sticas
      jQuery('#phase1-products').text(data.products_processed);
      jQuery('#phase1-images').text(data.images_processed || 0);
      jQuery('#phase1-duplicates').text(data.duplicates_skipped || 0);
      jQuery('#phase1-errors').text(data.errors || 0);

      // Actualizar velocidad
      if (this.phase1StartTime) {
        const elapsedSeconds = (Date.now() - this.phase1StartTime) / 1000;
        const speed = elapsedSeconds > 0
          ? (data.products_processed / elapsedSeconds).toFixed(2)
          : 0;
        jQuery('#phase1-speed').text(speed + ' ' + ((DASHBOARD_CONFIG && DASHBOARD_CONFIG.messages && DASHBOARD_CONFIG.messages.progress && DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg'));
      }
    }

    updatePhase2Progress(data) {
      const stats = data.estadisticas || {};
      const percentage = data.porcentaje || 0;

      jQuery('#phase2-progress-fill').css('width', percentage + '%');
      jQuery('#phase2-percentage').text(percentage.toFixed(1) + '%');
      jQuery('#phase2-progress-text').text(
        `${stats.procesados || 0}/${stats.total || 0} ${(DASHBOARD_CONFIG && DASHBOARD_CONFIG.messages && DASHBOARD_CONFIG.messages.progress && DASHBOARD_CONFIG.messages.progress.productsSynced) || 'productos sincronizados'}`
      );

      // Actualizar estad√≠sticas
      jQuery('#phase2-products').text(stats.procesados || 0);
      jQuery('#phase2-errors').text(stats.errores || 0);

      // Actualizar velocidad
      if (this.phase2StartTime) {
        const elapsedSeconds = (Date.now() - this.phase2StartTime) / 1000;
        const speed = elapsedSeconds > 0
          ? ((stats.procesados || 0) / elapsedSeconds).toFixed(2)
          : 0;
        jQuery('#phase2-speed').text(speed + ' ' + ((DASHBOARD_CONFIG && DASHBOARD_CONFIG.messages && DASHBOARD_CONFIG.messages.progress && DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg'));
      }
    }

    updatePhaseStatus(phase, status) {
      const $statusElement = jQuery(`#phase${phase}-status`);
      $statusElement.removeClass('phase-status-pending phase-status-running phase-status-completed phase-status-error phase-status-paused');
      $statusElement.addClass(`phase-status-${status}`);

      const getStatusMessage = function(key, defaultValue) {
        if (DASHBOARD_CONFIG && DASHBOARD_CONFIG.messages && DASHBOARD_CONFIG.messages.status && DASHBOARD_CONFIG.messages.status[key]) {
          return DASHBOARD_CONFIG.messages.status[key];
        }
        return defaultValue;
      };
      
      const statusText = {
        'pending': '‚è≥ ' + getStatusMessage('pending', 'Pendiente'),
        'running': 'üîÑ ' + getStatusMessage('running', 'En Progreso'),
        'completed': '‚úÖ ' + getStatusMessage('completed', 'Completado'),
        'error': '‚ùå ' + getStatusMessage('error', 'Error'),
        'paused': '‚è∏ ' + getStatusMessage('paused', 'Pausado')
      };

      $statusElement.text(statusText[status] || statusText['pending']);
    }

    startTimer(phase) {
      const timerElement = jQuery(`#phase${phase}-timer`);
      let seconds = 0;

      const timer = setInterval(() => {
        seconds++;
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;

        timerElement.text(
          `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
        );
      }, 1000);

      if (phase === 1) {
        this.phase1Timer = timer;
      } else {
        this.phase2Timer = timer;
      }
    }

    stopTimer(phase) {
      if (phase === 1 && this.phase1Timer) {
        clearInterval(this.phase1Timer);
        this.phase1Timer = null;
      } else if (phase === 2 && this.phase2Timer) {
        clearInterval(this.phase2Timer);
        this.phase2Timer = null;
      }
    }

    pausePhase1() {
      this.updatePhaseStatus(1, 'paused');
      this.stopTimer(1);
      this.disableButton('pause-phase1');
      this.enableButton('resume-phase1');
      addConsoleLine('warning', 'Fase 1 pausada');
    }

    resumePhase1() {
      this.updatePhaseStatus(1, 'running');
      this.phase1StartTime = Date.now() - (this.phase1StartTime ? (Date.now() - this.phase1StartTime) : 0);
      this.startTimer(1);
      this.disableButton('resume-phase1');
      this.enableButton('pause-phase1');
      addConsoleLine('info', 'Fase 1 reanudada');
    }

    pausePhase2() {
      this.updatePhaseStatus(2, 'paused');
      this.stopTimer(2);
      addConsoleLine('warning', 'Fase 2 pausada');
    }

    enableButton(id) {
      const $button = jQuery('#' + id);
      if ($button.length) {
        $button.prop('disabled', false);
        $button.show();
      }
    }

    disableButton(id) {
      const $button = jQuery('#' + id);
      if ($button.length) {
        $button.prop('disabled', true);
      }
    }

    updateConfig(key, value) {
      if (key === 'batch_size') {
        AjaxManager.call('mi_integracion_api_save_batch_size', {
          entity: 'productos',
          batch_size: value
        }, function(response) {
          if (response.success) {
            addConsoleLine('info', 'Configuraci√≥n de batch size actualizada: ' + value);
          }
        });
      } else if (key === 'throttle_delay') {
        const delaySeconds = parseFloat(value) / 1000;
        jQuery.ajax({
          url: ajaxurl,
          method: 'POST',
          data: {
            action: 'mia_update_throttle_delay',
            nonce: miIntegracionApiDashboard.nonce,
            delay: delaySeconds
          },
          success(response) {
            if (response.success) {
              addConsoleLine('info', 'Delay de throttling actualizado: ' + value + 'ms');
            }
          }
        });
      }
    }

    async loadCurrentStatus() {
      try {
        const response = await jQuery.ajax({
          url: ajaxurl,
          method: 'POST',
          data: {
            action: 'mia_get_sync_progress',
            nonce: miIntegracionApiDashboard.nonce
          }
        });

        if (response.success && response.data) {
          this.updateDashboardFromStatus(response.data);
        }
      } catch (error) {
        console.error('Error cargando estado:', error);
      }
    }

    updateDashboardFromStatus(data) {
      // Actualizar estado de Fase 1
      const phase1Status = data.phase1_images || {};
      if (phase1Status.in_progress) {
        this.updatePhaseStatus(1, 'running');
        this.updatePhase1Progress(phase1Status);
        if (!this.phase1Timer) {
          this.phase1StartTime = Date.now();
          this.startTimer(1);
        }
      } else if (phase1Status.completed) {
        this.updatePhaseStatus(1, 'completed');
        this.stopTimer(1);
        this.enableButton('start-phase2');
        this.updatePhase1Progress(phase1Status);
      }

      // Actualizar estado de Fase 2
      if (data.in_progress && !phase1Status.in_progress) {
        this.updatePhaseStatus(2, 'running');
        this.updatePhase2Progress(data);
        if (!this.phase2Timer) {
          this.phase2StartTime = Date.now();
          this.startTimer(2);
        }
      } else if (data.is_completed) {
        this.updatePhaseStatus(2, 'completed');
        this.stopTimer(2);
        this.updatePhase2Progress(data);
      }
    }

    handlePhase1Response(data) {
      if (data && data.in_progress) {
        // Iniciar polling para monitorear Fase 1
        if (typeof pollingManager !== 'undefined') {
          pollingManager.config.currentInterval = pollingManager.config.intervals.active;
          pollingManager.config.currentMode = 'active';
        }
      }
    }
  }

  // ‚úÖ NUEVO: Inicializar controles del terminal y dashboard
  jQuery(document).ready(function() {
    // Bot√≥n de limpiar consola
    jQuery('#mia-console-clear').on('click', function() {
      jQuery('#mia-console-content').empty();
      addConsoleLine('info', 'Consola limpiada');
    });

    // Bot√≥n de minimizar/maximizar
    jQuery('#mia-console-toggle').on('click', function() {
      const $console = jQuery('#mia-sync-console');
      const $icon = jQuery(this).find('.dashicons');

      $console.toggleClass('minimized');

      if ($console.hasClass('minimized')) {
        $icon.removeClass('dashicons-arrow-up-alt2').addClass('dashicons-arrow-down-alt2');
      } else {
        $icon.removeClass('dashicons-arrow-down-alt2').addClass('dashicons-arrow-up-alt2');
      }
    });

    // Inicializar SyncDashboard
    if (jQuery('#sync-two-phase-dashboard').length) {
      window.syncDashboard = new SyncDashboard();

      // Polling para actualizaciones en tiempo real
      setInterval(() => {
        if (window.syncDashboard) {
          window.syncDashboard.loadCurrentStatus();
        }
      }, 3000); // Actualizar cada 3 segundos
    }
  });

  // Funci√≥n para mostrar notificaciones
  function showNotification(message, type = 'info') {
    const typeClass = type === 'success' ? 'notice-success' : 
                     type === 'warning' ? 'notice-warning' : 
                     type === 'error' ? 'notice-error' : 'notice-info';
    
    const notificationHtml = `
      <div class="notice ${typeClass} is-dismissible">
        <p>${message}</p>
      </div>
    `;
    
    jQuery('#mia-dashboard-container').prepend(notificationHtml);
    
    // Auto-eliminar despu√©s de 5 segundos
    setTimeout(() => {
      jQuery('.notice').first().fadeOut(500, function() {
        jQuery(this).remove();
      });
    }, 5000);
  }

  // ‚úÖ NUEVO: Funci√≥n para iniciar Fase 2 (sincronizaci√≥n de productos)
  // Usar Phase2Manager si est√° disponible, sino fallback a funci√≥n inline
  function startPhase2() {
    if (typeof Phase2Manager !== 'undefined' && Phase2Manager && typeof Phase2Manager.start === 'function') {
      Phase2Manager.start();
    } else if (typeof window !== 'undefined' && window.startPhase2 && typeof window.startPhase2 === 'function') {
      window.startPhase2();
    } else {
      // Fallback: si Phase2Manager no est√° disponible, mostrar error
      console.error('Phase2Manager no est√° disponible');
      if (typeof ErrorHandler !== 'undefined' && ErrorHandler && typeof ErrorHandler.logError === 'function') {
        ErrorHandler.logError('Phase2Manager no est√° disponible', 'PHASE2_START');
      }
    }
  }

  // Funci√≥n para la sincronizaci√≥n normal - Usar SyncController si est√° disponible
  function proceedWithSync(originalText) {
    if (typeof SyncController !== 'undefined' && SyncController && typeof SyncController.proceedWithSync === 'function') {
      SyncController.proceedWithSync(originalText);
    } else if (typeof window !== 'undefined' && window.proceedWithSync && typeof window.proceedWithSync === 'function') {
      window.proceedWithSync(originalText);
    } else {
      // Fallback: si SyncController no est√° disponible, mostrar error
      console.error('SyncController no est√° disponible');
      if (typeof ErrorHandler !== 'undefined' && ErrorHandler && typeof ErrorHandler.logError === 'function') {
        ErrorHandler.logError('SyncController no est√° disponible', 'SYNC_START');
      }
      if (DOM_CACHE && DOM_CACHE.$syncBtn) {
        DOM_CACHE.$syncBtn.prop('disabled', false).text(originalText);
      }
      if (DOM_CACHE && DOM_CACHE.$batchSizeSelector) {
        DOM_CACHE.$batchSizeSelector.prop('disabled', false);
      }
      if (DOM_CACHE && DOM_CACHE.$feedback) {
        DOM_CACHE.$feedback.text('Error: SyncController no est√° disponible');
      }
    }
  }

  // Manejador de clic simplificado para el bot√≥n de sincronizaci√≥n
  DOM_CACHE.$syncBtn.on('click', function(e) {
    e.preventDefault();

    // PROTECCI√ìN SIMPLIFICADA: Solo bloquear clicks claramente autom√°ticos
    const isAutomaticClick = (
      // Solo bloquear si isTrusted est√° expl√≠citamente false
      (e.isTrusted === false) ||
      // Solo bloquear si no hay coordenadas Y no hay evento original
      (e.clientX === 0 && e.clientY === 0 && !e.originalEvent)
    );
    
    
    if (isAutomaticClick) {
      const reason = e.isTrusted === false ? 'isTrusted=false' : 'sin coordenadas ni originalEvent';
      ErrorHandler.showProtectionError(reason);
      return;
    }
    
    
    // Iniciar sincronizaci√≥n directamente
    const $btn = $(this);
    const originalText = $btn.text();
    
    $btn.prop('disabled', true).text('Iniciando sincronizaci√≥n...');
    
    // Llamar a la funci√≥n de sincronizaci√≥n pasando originalText
    proceedWithSync(originalText);
  });

  DOM_CACHE.$cancelBtn.on('click', function(e) {
    e.preventDefault();
    
    // Usar el mensaje localizado si est√° disponible
    const confirmMessage = miIntegracionApiDashboard && miIntegracionApiDashboard.confirmCancel 
        ? miIntegracionApiDashboard.confirmCancel 
        : '¬øSeguro que deseas cancelar la sincronizaci√≥n?';
    
    if (!confirm(confirmMessage)) return;

    // Obtener el texto original del bot√≥n antes de la cancelaci√≥n
    
    AjaxManager.call('mia_sync_cancel', {}, function(response) {
      if (response.success) {
          // Limpiar polling tradicional si est√° activo
        clearInterval(syncInterval);
        pollingManager.stopPolling('syncProgress');          
          
        DOM_CACHE.$feedback.removeClass('in-progress').text('Sincronizaci√≥n cancelada.');
        DOM_CACHE.$syncBtn.prop('disabled', false).text(window.originalSyncButtonText || 'Sincronizar productos en lote');
        DOM_CACHE.$batchSizeSelector.prop('disabled', false);
          
          // Deshabilitar bot√≥n de cancelar inmediatamente
        DOM_CACHE.$cancelBtn.prop('disabled', true);
          
          // Ocultar contenedor de estado despu√©s de un breve delay
        setTimeout(() => {
          DOM_CACHE.$syncStatusContainer.hide();
        }, 2000);
          
          // Estado manejado por PHP - no necesario marcar en JavaScript
          
          // Verificar que la cancelaci√≥n fue efectiva
        setTimeout(() => {
          AjaxManager.call('mia_get_sync_progress', {}, function(verifyResponse) {
            if (verifyResponse.success && verifyResponse.data && verifyResponse.data.sync) {
              const stillInProgress = verifyResponse.data.sync.in_progress;
              if (stillInProgress) {
                ErrorHandler.logError('ADVERTENCIA: Sincronizaci√≥n a√∫n en progreso despu√©s de cancelar', 'CANCEL_VERIFY');
                DOM_CACHE.$feedback.text('Sincronizaci√≥n cancelada (verificando estado...)');
              } else {
                ErrorHandler.logError('Sincronizaci√≥n cancelada exitosamente', 'CANCEL_VERIFY');
              }
            }
          });
        }, 1000);
          
      } else {
        DOM_CACHE.$feedback.removeClass('in-progress').text('Error al cancelar: ' + ((response.data && response.data.mensaje) || 'Error desconocido'));
        ErrorHandler.logError('Error al cancelar', 'CANCEL');
      }
    },
      function(xhr, status, error) {
        const errorMessage = error || 'Error desconocido';
        ErrorHandler.showCancelError(`${status}: ${errorMessage}`, 'CANCEL');
        
        // Verificar que xhr no sea null antes de acceder a sus propiedades
        const statusCode = xhr ? xhr.status : 'N/A';
        DOM_CACHE.$feedback.removeClass('in-progress').text('Error al comunicarse con el servidor. C√≥digo: ' + statusCode);
        // No deshabilitamos el bot√≥n para permitir intentar de nuevo
      }
    );
  });  

  // ========================================
  // API B√ÅSICA DE DIAGN√ìSTICO - HERRAMIENTAS DE DEBUGGING
  // ========================================
  
  /**
   * Funci√≥n de diagn√≥stico para probar conectividad AJAX
   * Reutiliza patrones existentes del archivo para mantener consistencia
   * 
   * @function diagnosticAjaxCall
   * @description Prueba la conectividad AJAX b√°sica del sistema
   * @returns {void}
   * @since 1.0.0
   * @example
   * // Ejecutar diagn√≥stico desde consola
   * diagnosticAjaxCall();
   */
  function diagnosticAjaxCall() {
    // REUTILIZAR: Patr√≥n de validaci√≥n existente (l√≠nea 1192)
    if (typeof miIntegracionApiDashboard === 'undefined' || !miIntegracionApiDashboard.nonce) {
      console.error('No se puede verificar el estado: configuraci√≥n no disponible');
      return;
    }
    
    // REUTILIZAR: Patr√≥n de logging de diagn√≥stico (l√≠nea 1219)
    
    // REUTILIZAR: Estructura AJAX existente (l√≠neas 1197-1215)
    jQuery.ajax({
      url: ajaxurl,
      type: 'POST',
      data: {
        action: 'mia_get_sync_progress', // REUTILIZAR: Endpoint existente y confiable
        nonce: miIntegracionApiDashboard.nonce
      },
      success(response) {
        // REUTILIZAR: Patr√≥n de logging existente
      },
      error(xhr, status, error) {
        // REUTILIZAR: Patr√≥n de manejo de errores existente (l√≠nea 1213)
      }
    });
    
    // REUTILIZAR: Patr√≥n de logging de fin de diagn√≥stico (l√≠nea 1265)
  }
  
  /**
   * API b√°sica de diagn√≥stico para desarrolladores
   * @namespace BasicDiagnosticAPI
   * @description Herramientas de diagn√≥stico b√°sicas para desarrolladores
   * 
   * @example
   * // Probar conectividad AJAX
   * BasicDiagnosticAPI.testAjax();
   * 
   * // Verificar estado de sincronizaci√≥n
   * BasicDiagnosticAPI.checkSyncStatus();
   * 
   * // Mostrar/ocultar contenedor de sincronizaci√≥n
   * BasicDiagnosticAPI.toggleSyncContainer(true);
   * 
   * @since 1.0.0
   * @author Christian
   */
  if (typeof window !== 'undefined') {
    window.BasicDiagnosticAPI = {
      testAjax: diagnosticAjaxCall,
      // clearSyncState eliminado - estado manejado por PHP
      /**
       * Mostrar/ocultar contenedor de sincronizaci√≥n manualmente
       * @param {boolean} [show] - true para mostrar, false para ocultar, undefined para toggle
       * @returns {boolean} true si est√° visible, false si est√° oculto
       * @example
       * BasicDiagnosticAPI.toggleSyncContainer(true);  // Mostrar
       * BasicDiagnosticAPI.toggleSyncContainer(false); // Ocultar
       * BasicDiagnosticAPI.toggleSyncContainer();      // Toggle
       */
      toggleSyncContainer(show) {
        const $container = DOM_CACHE.$syncStatusContainer;
        const $button = $('#toggle-sync-details');
        
        // L√≥gica de toggle mejorada
        if (typeof show === 'undefined') {
          $container.toggle();
        } else {
          $container.toggle(show);
        }
        
        // Actualizar estado del bot√≥n si existe
        if ($button.length) {
          const isVisible = $container.is(':visible');
          $button.find('.dashicons').toggleClass('dashicons-visibility', !isVisible)
                                .toggleClass('dashicons-hidden', isVisible);
          $button.find('span:not(.dashicons)').text(isVisible ? 'Ocultar' : 'Mostrar');
        }
        
        // Logging mejorado
        
        // Emitir evento personalizado para integraci√≥n
        window.dispatchEvent(new CustomEvent('sync-container-toggled', {
          detail: { 
            visible: $container.is(':visible'),
            timestamp: Date.now(),
            source: 'BasicDiagnosticAPI'
          }
        }));
        
        return $container.is(':visible');
      },
      // FUNCI√ìN EN DESUSO - Diagnosticar problemas de sincronizaci√≥n autom√°tica
      // Esta funci√≥n est√° comentada porque no se utiliza en la interfaz actual
      // pero se mantiene para debugging avanzado y posible uso futuro
      /*
      diagnoseAutoSync: function() {
        
        // 1. Verificar estado actual
        this.checkSyncStatus();
        
        // 2. Verificar si hay locks activos
        jQuery.ajax({
          url: ajaxurl,
          type: 'POST',
          data: {
            action: 'mia_sync_status',
            nonce: miIntegracionApiDashboard.nonce
          },
          success: function(response) {
          },
          error: function(xhr, status, error) {
            console.error('Error al verificar estado detallado:', status, error);
          }
        });
        
        // Verificar si hay transients activos
        jQuery.ajax({
          url: ajaxurl,
          type: 'POST',
          data: {
            action: 'mia_clear_sync_state',
            nonce: miIntegracionApiDashboard.nonce
          },
          success: function(response) {
          },
          error: function(xhr, status, error) {
            console.error('Error al limpiar estado:', status, error);
          }
        });
        
      },
      */
      /**
       * Mostrar informaci√≥n sobre las funciones disponibles
       * @returns {void}
       * @example
       * BasicDiagnosticAPI.info();
       */
      info() {
      }
    };    
  }

  // ========================================
  // SECCI√ìN 3: ANIMACIONES Y EFECTOS UX
  // ========================================
  
  // Animaciones de entrada para las tarjetas
  $(SELECTORS.STAT_CARD).each(function(index) {
    $(this).css({
      'opacity': '0',
      'transform': 'translateY(20px)'
    }).delay(index * 100).animate({
      'opacity': '1',
      'transform': 'translateY(0)'
    }, 500, 'swing');
  });
  
  // Efecto contador animado para las estad√≠sticas
  $(SELECTORS.STAT_VALUE).each(function() {
    const $this = $(this);
    const target = parseInt($this.text()) || 0;
    
    if (target > 0) {
      $this.text('0');
      $({ counter: 0 }).animate({ counter: target }, {
        duration: 1500,
        easing: 'swing',
        step() {
          $this.text(Math.ceil(this.counter));
        },
        complete() {
          $this.text(target);
        }
      });
    }
  });
  
  // Agregar tooltips informativos y funcionalidad de clic
  $(SELECTORS.STAT_CARD).each(function() {
    const $card = $(this);
    $card.attr('title', 'Haz clic para actualizar datos');
        
    // Funcionalidad de clic para actualizar datos
    $card.on('click', function(e) {
      e.preventDefault();
      
      // Agregar efecto visual de clic
      $(this).addClass('card-clicked');
      setTimeout(() => {
        $(this).removeClass('card-clicked');
      }, 200);
      
      // Actualizar datos de la tarjeta espec√≠fica
      if (typeof CardManager !== 'undefined' && CardManager && CardManager.updateCardData) {
        CardManager.updateCardData($(this));
      } else if (typeof updateCardData !== 'undefined') {
        // Fallback para compatibilidad con c√≥digo antiguo
        updateCardData($(this));
      } else {
        // eslint-disable-next-line no-console
        console.warn('CardManager no est√° disponible. La funcionalidad de actualizaci√≥n de tarjetas podr√≠a no funcionar.');
      }
    });
  });
  
  // Funciones updateCardData y updateSpecificCard han sido movidas a CardManager.js
  // Se mantienen aqu√≠ como fallback para compatibilidad con c√≥digo antiguo
  // TODO: Eliminar estas funciones una vez confirmado que CardManager funciona correctamente
  function updateCardData($card) {
    if (typeof CardManager !== 'undefined' && CardManager && CardManager.updateCardData) {
      return CardManager.updateCardData($card);
    }
    // eslint-disable-next-line no-console
    console.warn('updateCardData: CardManager no est√° disponible. Esta funci√≥n ha sido movida a CardManager.js');
  }
  
  function updateSpecificCard($card, cardType, data) {
    if (typeof CardManager !== 'undefined' && CardManager && CardManager.updateSpecificCard) {
      return CardManager.updateSpecificCard($card, cardType, data);
    }
    // eslint-disable-next-line no-console
    console.warn('updateSpecificCard: CardManager no est√° disponible. Esta funci√≥n ha sido movida a CardManager.js');
  }
  
// Notificaciones toast modernas
  function showToast(message, type = 'info', duration = 4000) {
    const toastClass = {
      'success': 'toast-success',
      'error': 'toast-error',
      'warning': 'toast-warning',
      'info': 'toast-info'
    }[type] || 'toast-info';
    
    const $toast = $(`
      <div class="mi-toast ${toastClass}" style="
        position: fixed;
        top: 32px;
        right: 20px;
        background: white;
        padding: 1rem 1.5rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        border-left: 4px solid var(--dashboard-primary);
        z-index: 9999;
        max-width: 400px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
      ">
        <div style="display: flex; align-items: center; gap: 0.75rem;">
          <span class="toast-icon" style="font-size: 1.25rem;">
            ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è'}
          </span>
          <span class="toast-message" style="color: #374151; font-weight: 500;">${message}</span>
          <button class="toast-close" style="
            background: none;
            border: none;
            font-size: 1.25rem;
            cursor: pointer;
            color: #9ca3af;
            margin-left: auto;
          ">√ó</button>
        </div>
      </div>
    `);
    
    // Colores por tipo
    if (type === 'success') $toast.css('border-left-color', '#22c55e');
    if (type === 'error') $toast.css('border-left-color', '#ef4444');
    if (type === 'warning') $toast.css('border-left-color', '#f59e0b');
    
    $('body').append($toast);
    
    // Animaci√≥n de entrada
    setTimeout(() => {
      $toast.css('transform', 'translateX(0)');
    }, 100);
    
    // Auto-close
    setTimeout(() => {
      $toast.css('transform', 'translateX(100%)');
      setTimeout(() => $toast.remove(), DASHBOARD_CONFIG.ui.animation.fadeIn);
    }, duration);
    
    // Click para cerrar
    $toast.find('.toast-close').click(() => {
      $toast.css('transform', 'translateX(100%)');
      setTimeout(() => $toast.remove(), DASHBOARD_CONFIG.ui.animation.fadeIn);
    });
  }
  
  // Mejorar el bot√≥n de sincronizaci√≥n con feedback visual
  const $syncButton = $('#mi-batch-sync-products');
  
  // COMENTADO TEMPORALMENTE - Manejador duplicado, usando el nuevo en l√≠nea 1260
  // TODO: Eliminar una vez confirmado que el nuevo manejador funciona correctamente
  /*
  $syncButton.on('click', function() {
    const $btn = $(this);
    if (!$btn.is(':disabled')) {
      showToast('Iniciando sincronizaci√≥n...', 'info');
      
      // Agregar animaci√≥n de loading
      $btn.addClass('loading').prop('disabled', true);
      $btn.find('.dashicons').addClass('spin');
    }
  });
  */
  
  // Mejorar el selector de batch size con feedback visual Y GUARDADO AUTOM√ÅTICO
  $('#mi-batch-size').on('change', function() {
    const size = $(this).val();
    showToast(DASHBOARD_CONFIG.messages.success.batchSizeChanged.replace('{size}', size), 'info', DASHBOARD_CONFIG.ui.toastDuration.short);
    
    // GUARDAR AUTOM√ÅTICAMENTE el valor cuando el usuario lo cambia
    AjaxManager.call('mi_integracion_api_save_batch_size', {
      entity: 'productos',
      batch_size: size
    }, function(response) {
      if (response.success) {
        // Batch size guardado correctamente
      } else {
        ErrorHandler.logError('Error guardando batch size', 'BATCH_SIZE');
        showToast('Error guardando configuraci√≥n', 'error', DASHBOARD_CONFIG.ui.toastDuration.medium);
      }
    }, (xhr, status, error) => {
      ErrorHandler.showConnectionError(xhr);
      const errorMessage = status === 'timeout' ? 'Timeout al guardar' : 
                            status === 'abort' ? 'Operaci√≥n cancelada' : 
                            error || 'Error de comunicaci√≥n al guardar';
      showToast(errorMessage, 'error', DASHBOARD_CONFIG.ui.toastDuration.medium);
    });
  });
  
  // Agregar indicador de estado de conexi√≥n
  function checkConnectionStatus() {
    const statusHtml = `
      <div class="connection-status" style="
        position: fixed;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        background: white;
        padding: 0.5rem;
        border-radius: 50%;
        box-shadow: var(--dashboard-shadow);
        z-index: 1000;
      ">
        <div class="status-dot" style="
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: ${navigator.onLine ? '#22c55e' : '#ef4444'};
        "></div>
      </div>
    `;
    
    const $statusIndicator = $(statusHtml);
    
    if (!$('.connection-status').length) {
      $('body').append($statusIndicator);
    }
    
    // Actualizar cada 30 segundos (con verificaci√≥n de seguridad mejorada)
    let connectionTimeout = 30000; // Fallback por defecto
    
    try {
      if (typeof DASHBOARD_CONFIG !== 'undefined' && 
          DASHBOARD_CONFIG && 
          DASHBOARD_CONFIG.timeouts && 
          typeof DASHBOARD_CONFIG.timeouts.connection === 'number') {
        connectionTimeout = DASHBOARD_CONFIG.timeouts.connection;
      }
    } catch (error) {
      console.warn('Error accediendo a DASHBOARD_CONFIG.timeouts.connection:', error);
    }
    
    setTimeout(checkConnectionStatus, connectionTimeout);
  }
  
  checkConnectionStatus();
  
  // Agregar atajos de teclado
  jQuery(document).on('keydown', function(e) {
    // Ctrl + Enter para sincronizar
    if (e.ctrlKey && e.keyCode === 13) {
      e.preventDefault();
      if (!$syncButton.is(':disabled')) {
        $syncButton.trigger('click');
        showToast(DASHBOARD_CONFIG.messages.tips.keyboardShortcut, 'info', DASHBOARD_CONFIG.ui.toastDuration.short);
      }
    }
    
    // Escape para cancelar
    if (e.keyCode === 27) {
      const $cancelButton = $('#mi-cancel-sync');
      if ($cancelButton.is(':visible') && !$cancelButton.is(':disabled')) {
        $cancelButton.trigger('click');
      }
    }
  });
  
  // Mostrar tips de ayuda
  setTimeout(() => {
    showToast(DASHBOARD_CONFIG.messages.tips.generalTip, 'info', DASHBOARD_CONFIG.ui.toastDuration.extraLong);
  }, (DASHBOARD_CONFIG && DASHBOARD_CONFIG.timeouts && DASHBOARD_CONFIG.timeouts.long) ? DASHBOARD_CONFIG.timeouts.long : 5000);
  
  // Event listener para el bot√≥n de toggle de detalles de sincronizaci√≥n
  $('#toggle-sync-details').on('click', function(e) {
    e.preventDefault();
    BasicDiagnosticAPI.toggleSyncContainer();
  });
  

  
  // ========================================
  // FIN DEL DOCUMENT READY CONSOLIDADO
  // ========================================
});

// Dashboard unificado con diagn√≥stico autom√°tico
(function() {
  'use strict';    
    /**
     * ========================================
     * UNIFIED DASHBOARD - DASHBOARD UNIFICADO COMPLETO
     * ========================================
     * 
     * @class UnifiedDashboard
     * @description Gesti√≥n completa del dashboard y todas sus funcionalidades
     * @namespace UnifiedDashboard
     * 
 * @example
 * // Inicializar dashboard (uso directo)
 * UnifiedDashboard.init();
 * 
 * // Ejecutar diagn√≥stico del sistema (uso directo)
 * UnifiedDashboard.runSystemDiagnostic();
 * 
 * // Tambi√©n disponible como window.UnifiedDashboard
 * window.UnifiedDashboard.init();
     * 
     * @since 1.0.0
     * @author Christian
     */
  const UnifiedDashboard = {
        // SIMPLIFICADO: Configuraci√≥n b√°sica - PHP maneja l√≥gica adaptativa
    config: {
      refreshInterval: 60000, // 60 segundos (base)
      diagnosticTimeout: 30000, // 30 segundos
      debugMode: false // Control de logs verbosos
    },
        
        // Estado del sistema
    systemState: {
      lastCheck: null,
      overallHealth: 'unknown',
      lastHealth: 'unknown',
      issues: [],
      recommendations: []
    },
        
        /**
         * Inicializar el dashboard unificado
         * @returns {void}
         * @example
         * UnifiedDashboard.init();
         */
    init() {
      this.bindEvents();
    },
        
        /**
         * Activar/desactivar modo debug
         * @returns {void}
         * @example
         * UnifiedDashboard.toggleDebugMode();
         */
    toggleDebugMode() {
      this.config.debugMode = !this.config.debugMode;
      const $btn = jQuery('#toggle-debug-mode');
      if (this.config.debugMode) {
        $btn.removeClass('button-secondary').addClass('button-primary');
        $btn.html('<span class="dashicons dashicons-admin-tools"></span> Debug: ON');
                // Modo debug activado
      } else {
        $btn.removeClass('button-primary').addClass('button-secondary');
        $btn.html('<span class="dashicons dashicons-admin-tools"></span> Debug: OFF');
                // Modo debug desactivado
      }
    },
        
        /**
         * Vincular eventos del dashboard
         * @returns {void}
         * @private
         */
    bindEvents() {
            // Bot√≥n de diagn√≥stico completo
      jQuery(document).on('click', '#run-system-diagnostic', (e) => {
        e.preventDefault();
        this.runSystemDiagnostic();
      });
            
            // Bot√≥n de refrescar estado
      jQuery(document).on('click', '#refresh-system-status', (e) => {
        e.preventDefault();
        this.refreshSystemStatus();
      });
            
            // Bot√≥n de exportar reporte
      jQuery(document).on('click', '#export-system-report', (e) => {
        e.preventDefault();
        this.exportSystemReport();
      });
            
            // Bot√≥n de cargar m√©tricas adicionales
      jQuery(document).on('click', '#load-additional-metrics', (e) => {
        e.preventDefault();
        this.loadAdditionalMetrics();
      });
            
            // Bot√≥n de verificar estado de cron jobs
      jQuery(document).on('click', '#check-cron-status', (e) => {
        e.preventDefault();
        this.checkCronStatus();
      });
            
            // Bot√≥n de toggle debug mode
      jQuery(document).on('click', '#toggle-debug-mode', (e) => {
        e.preventDefault();
        this.toggleDebugMode();
      });
            
            // CORRECCI√ìN DE OPTIMIZACI√ìN: Botones para funcionalidades bajo demanda
      jQuery(document).on('click', '#execute-system-diagnostic', (e) => {
        e.preventDefault();
        this.executeSystemDiagnostic();
      });
            
      jQuery(document).on('click', '#initialize-assets', (e) => {
        e.preventDefault();
        this.initializeAssets();
      });
            
      jQuery(document).on('click', '#initialize-ajax', (e) => {
        e.preventDefault();
        this.initializeAjax();
      });
            
      jQuery(document).on('click', '#initialize-settings', (e) => {
        e.preventDefault();
        this.initializeSettings();
      });
            
      jQuery(document).on('click', '#initialize-cleanup', (e) => {
        e.preventDefault();
        this.initializeCleanup();
      });
            
      jQuery(document).on('click', '#load-textdomain', (e) => {
        e.preventDefault();
        this.loadTextdomain();
      });
            
            // CORRECCI√ìN DE OPTIMIZACI√ìN: Botones para compatibilidad bajo demanda
      jQuery(document).on('click', '#initialize-compatibility-reports', (e) => {
        e.preventDefault();
        this.initializeCompatibilityReports();
      });
            
      jQuery(document).on('click', '#initialize-theme-compatibility', (e) => {
        e.preventDefault();
        this.initializeThemeCompatibility();
      });
            
      jQuery(document).on('click', '#initialize-woocommerce-plugin-compatibility', (e) => {
        e.preventDefault();
        this.initializeWooCommercePluginCompatibility();
      });
            
      jQuery(document).on('click', '#initialize-general-compatibility', (e) => {
        e.preventDefault();
        this.initializeGeneralCompatibility();
      });
            
      jQuery(document).on('click', '#execute-complete-compatibility-check', (e) => {
        e.preventDefault();
        this.executeCompleteCompatibilityCheck();
      });
            
            // CORRECCI√ìN DE OPTIMIZACI√ìN: Botones para hooks adicionales bajo demanda
      jQuery(document).on('click', '#initialize-sync-hooks', (e) => {
        e.preventDefault();
        this.initializeSyncHooks();
      });
            
            
      jQuery(document).on('click', '#initialize-ajax-lazy-loading', (e) => {
        e.preventDefault();
        this.initializeAjaxLazyLoading();
      });
            
      jQuery(document).on('click', '#execute-batch-size-debug', (e) => {
        e.preventDefault();
        this.executeBatchSizeDebug();
      });
    },        
        
        // Ejecutar diagn√≥stico completo del sistema
    runSystemDiagnostic() {
      const $btn = jQuery('#run-system-diagnostic');
      const $results = jQuery('#diagnostic-results');
            
            // Mostrar estado de carga
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Ejecutando...');
      $results.show().html('<div class="diagnostic-loading"><span class="dashicons dashicons-update-alt"></span> Ejecutando diagn√≥stico completo del sistema...</div>');
            
      AjaxManager.call('mia_run_system_diagnostic', {},
                function(response) {
                  if (response.success) {
                    this.displayDiagnosticResults(response.data);
                    this.updateSystemHealth(response.data);
                  } else {
                    this.showError('Error en diagn√≥stico: ' + ((response.data && response.data.message) || 'Error desconocido'));
                  }
                },
                function(xhr, status, error) {
                  this.showError('Error de conexi√≥n: ' + error);
                }
            );
    },
        
        // Refrescar estado del sistema (SOLO MANUAL - NO AUTOM√ÅTICO)
    refreshSystemStatus() {
            // CONTROL DE ESTADO GLOBAL: Verificar si hay sincronizaci√≥n en progreso
      if (this.isSyncInProgress()) {
        return;
      }
            
      const $btn = jQuery('#refresh-system-status');
            
      AjaxManager.call('mia_system_status', {}, $btn,
                function(response) {
                  if (response.success) {
                    this.updateSystemStatus(response.data);
                    this.showSuccess('Estado del sistema actualizado correctamente');
                  } else {
                    this.showError('Error al refrescar: ' + ((response.data && response.data.message) || 'Error desconocido'));
                  }
                },
                function(xhr, status, error) {
                  this.showError('Error de conexi√≥n: ' + error);
                }
            );
    },
        
        // Exportar reporte del sistema
    exportSystemReport() {
      const $btn = jQuery('#export-system-report');
            
      AjaxManager.call('mia_export_system_report', {}, $btn,
                function(response) {
                  if (response.success) {
                    this.showSuccess('Reporte exportado correctamente');
                        
                        // Crear enlace de descarga
                    if (response.data) {
                            // Extraer propiedades usando destructuring con valores por defecto
                      const { download_url = null, filename = 'reporte.json' } = response.data;
                            
                      if (download_url) {
                        const $downloadLink = jQuery('<a>')
                                    .attr('href', download_url)
                                    .attr('download', filename)
                                    .addClass('button button-primary')
                                    .html('<span class="dashicons dashicons-download"></span> Descargar Reporte');
                                
                        $btn.after($downloadLink);
                                
                                // Auto-descargar despu√©s de 1 segundo
                        setTimeout(() => {
                          $downloadLink[0].click();
                          $downloadLink.remove();
                        }, 1000);
                      }
                    }
                  } else {
                    this.showError('Error al exportar: ' + ((response.data && response.data.message) || 'Error desconocido'));
                  }
                },
                function(xhr, status, error) {
                  this.showError('Error de conexi√≥n: ' + error);
                }
            );
    },
        
        // Mostrar resultados del diagn√≥stico
    displayDiagnosticResults(data) {
      const $results = jQuery('#diagnostic-results');
            
      let html = '<div class="diagnostic-summary">';
      html += '<h3>Resultados del Diagn√≥stico del Sistema</h3>';
      html += `<p><strong>Ejecutado:</strong> ${new Date(data.timestamp).toLocaleString()}</p>`;
            
            // Resumen de salud del sistema
      html += '<div class="health-summary">';
      if (data && typeof data === 'object' && 'system_health' in data && data.system_health) {
                // Extraer propiedades usando destructuring con valores por defecto
        const systemHealth = data.system_health;
        const { 
                    overall_status = 'unknown', 
                    status_message = null, 
                    components = null,
                    issues_count = 0,
                    issues = []
                } = systemHealth;
                
        html += `<h4>Estado General: <span class="health-status ${overall_status}">${this.getHealthStatusText(overall_status)}</span></h4>`;
                
        if (status_message) {
          html += `<p><strong>Estado:</strong> ${status_message}</p>`;
        }
                
        if (issues_count > 0) {
          html += `<p><strong>Problemas detectados:</strong> ${issues_count}</p>`;
          if (issues.length > 0) {
            html += '<ul>';
            issues.forEach(issue => {
              html += `<li>${issue}</li>`;
            });
            html += '</ul>';
          }
        }
                
        if (components) {
          html += '<div class="health-components">';
          Object.entries(components).forEach(([component, status]) => {
            if (status && status.status) {
              html += `<p><strong>${this.getComponentName(component)}:</strong> <span class="status-${status.status}">${this.getComponentStatusText(status.status)}</span></p>`;
            }
          });
          html += '</div>';
        }
      } else {
        html += '<h4>Estado General: <span class="health-status unknown">Desconocido</span></h4>';
        html += '<p>No se pudo obtener el estado del sistema</p>';
      }
      html += '</div>';
            
            // An√°lisis de memoria
      if (data && typeof data === 'object' && 'memory_analysis' in data && data.memory_analysis) {
                // Extraer propiedades usando destructuring con valores por defecto
        const memoryAnalysis = data.memory_analysis;
        const { 
                    status = 'unknown', 
                    usage_percentage = null, 
                    recommendations = []
                } = memoryAnalysis;
                
        html += '<div class="analysis-section">';
        html += '<h4>An√°lisis de Memoria</h4>';
        html += `<p><strong>Estado:</strong> <span class="status-${status}">${this.getMemoryStatusText(status)}</span></p>`;
                
        if (usage_percentage !== null && usage_percentage !== undefined) {
          html += `<p><strong>Uso:</strong> ${usage_percentage}%</p>`;
        }
                
        if (recommendations && recommendations.length > 0) {
          html += '<ul class="recommendations">';
          recommendations.forEach(rec => {
            html += `<li>${rec}</li>`;
          });
          html += '</ul>';
        }
        html += '</div>';
      }
            
            // An√°lisis de reintentos
      if (data && typeof data === 'object' && 'retry_analysis' in data && data.retry_analysis) {
                // Extraer propiedades usando destructuring con valores por defecto
        const retryAnalysis = data.retry_analysis;
        const { 
                    status = 'unknown', 
                    success_rate = null, 
                    recommendations = []
                } = retryAnalysis;
                
        html += '<div class="analysis-section">';
        html += '<h4>An√°lisis de Reintentos</h4>';
        html += `<p><strong>Estado:</strong> <span class="status-${status}">${this.getRetryStatusText(status)}</span></p>`;
                
        if (success_rate !== null && success_rate !== undefined) {
          html += `<p><strong>Tasa de √âxito:</strong> ${success_rate}%</p>`;
        }
                
        if (recommendations && recommendations.length > 0) {
          html += '<ul class="recommendations">';
          recommendations.forEach(rec => {
            html += `<li>${rec}</li>`;
          });
          html += '</ul>';
        }
        html += '</div>';
      }
            
            // An√°lisis de sincronizaci√≥n
      if (data && typeof data === 'object' && 'sync_analysis' in data && data.sync_analysis) {
                // Extraer propiedades usando destructuring con valores por defecto
        const syncAnalysis = data.sync_analysis;
        const { 
                    status = 'unknown', 
                    progress = null, 
                    total_items = null
                } = syncAnalysis;
                
        html += '<div class="analysis-section">';
        html += '<h4>An√°lisis de Sincronizaci√≥n</h4>';
        html += `<p><strong>Estado:</strong> <span class="status-${status}">${this.getSyncStatusText(status)}</span></p>`;
                
        if (progress !== null && progress !== undefined) {
          html += `<p><strong>Progreso:</strong> ${progress}%</p>`;
        }
                
        if (total_items !== null && total_items !== undefined) {
          html += `<p><strong>Total de elementos:</strong> ${total_items}</p>`;
        }
        html += '</div>';
      }
            
            // Recomendaciones
      if (data && typeof data === 'object' && 'recommendations' in data && data.recommendations && data.recommendations.length > 0) {
                // Extraer propiedades usando destructuring con valores por defecto
        const recommendations = data.recommendations;
                
        html += '<div class="recommendations-section">';
        html += '<h4>Recomendaciones del Sistema</h4>';
        html += '<div class="recommendations-grid">';
        recommendations.forEach(rec => {
          const { 
                        priority = 'medium', 
                        title = 'Recomendaci√≥n', 
                        description = 'Sin descripci√≥n',
                        action = null
                    } = rec;
                    
          html += '<div class="recommendation-item ' + priority + '">';
          html += '<div class="recommendation-header">';
          html += '<span class="priority-badge ' + priority + '">' + this.getPriorityText(priority) + '</span>';
          html += '<h5>' + title + '</h5>';
          html += '</div>';
          html += '<p>' + description + '</p>';
          if (action) {
            html += `<p class="action-required"><strong>Acci√≥n requerida:</strong> ${action}</p>`;
          }
          html += '</div>';
        });
        html += '</div>';
        html += '</div>';
      }
            
      html += '</div>';
            
      $results.html(html);
    },
        
        // Actualizar estado del sistema
    updateSystemStatus(data) {
      this.systemState.lastCheck = data.timestamp;
      if (data && typeof data === 'object' && 'overall_health' in data && data.overall_health) {
                // Extraer propiedades usando destructuring con valores por defecto
        const overallHealth = data.overall_health;
        const { 
                    status = 'unknown', 
                    components = {}
                } = overallHealth;
                
        if (status) {
          this.systemState.overallHealth = status;
                    // Los issues ahora vienen de los componentes individuales
          this.systemState.issues = [];
          if (components && typeof components === 'object') {
            Object.entries(components).forEach(([component, componentStatus]) => {
              if (componentStatus && componentStatus.status && componentStatus.status !== 'healthy') {
                this.systemState.issues.push(`${this.getComponentName(component)}: ${this.getComponentStatusText(componentStatus.status)}`);
              }
            });
          }
        }
      } else {
        this.systemState.overallHealth = 'unknown';
        this.systemState.issues = [];
      }
            
            // Actualizar indicadores visuales si existen
      this.updateHealthIndicators(data);
    },
        
        // Actualizar indicadores de salud
    updateHealthIndicators(data) {
            // Actualizar tarjetas de estado si existen
      if (data.memory) {
        this.updateMemoryCard(data.memory);
      }
      if (data.retry) {
        this.updateRetryCard(data.retry);
      }
      if (data.sync) {
        this.updateSyncCard(data.sync);
      }
    },
        
        // Actualizar tarjeta de memoria
    updateMemoryCard(memoryData) {
      const $card = jQuery(SELECTORS.STAT_CARD_MEMORY);
      if ($card.length && memoryData) {
                // Extraer propiedades usando destructuring con valores por defecto
        const { 
                    usage_percentage = '0', 
                    status = 'unknown'
                } = memoryData;
                
        // Validar estado de memoria - solo aceptar estados v√°lidos
        const validMemoryStates = ['healthy', 'warning', 'critical'];
        const validatedStatus = validMemoryStates.includes(status) ? status : 'unknown';
        
        $card.find(SELECTORS.STAT_VALUE).text(usage_percentage + '%');
        $card.removeClass('healthy warning critical').addClass(validatedStatus);
        
        // Log de advertencia si se recibi√≥ un estado inv√°lido
        if (!validMemoryStates.includes(status)) {
          console.warn('Estado de memoria inv√°lido recibido:', status, 'Usando estado por defecto: unknown');
        }
      }
    },
        
        // Actualizar tarjeta de reintentos
    updateRetryCard(retryData) {
      const $card = jQuery(SELECTORS.STAT_CARD_RETRIES);
      if ($card.length && retryData) {
                // Extraer propiedades usando destructuring con valores por defecto
        const { 
                    success_rate = '0', 
                    status = 'unknown'
                } = retryData;
                
        $card.find(SELECTORS.STAT_VALUE).text(success_rate + '%');
        $card.removeClass('healthy warning critical').addClass(status);
      }
    },
        
        // Actualizar tarjeta de sincronizaci√≥n
    updateSyncCard(syncData) {
      const $card = jQuery(SELECTORS.STAT_CARD_SYNC);
      if ($card.length && syncData) {
                // Extraer propiedades usando destructuring con valores por defecto
        const { 
                    status = 'unknown'
                } = syncData;
                
        $card.find(SELECTORS.STAT_VALUE).text(this.getSyncStatusText(status));
        $card.removeClass('healthy warning critical').addClass(status);
      }
    },
        
        // Actualizar salud del sistema
    updateSystemHealth(data) {
      if (data && typeof data === 'object' && 'system_health' in data && data.system_health) {
                // Extraer propiedades usando destructuring con valores por defecto
        const systemHealth = data.system_health;
        const { 
                    status = 'unknown', 
                    components = {}
                } = systemHealth;
                
        if (status) {
          this.systemState.overallHealth = status;
                    // Los issues ahora vienen de los componentes individuales
          this.systemState.issues = [];
          if (components && typeof components === 'object') {
            Object.entries(components).forEach(([component, componentStatus]) => {
              if (componentStatus && componentStatus.status && componentStatus.status !== 'healthy') {
                this.systemState.issues.push(`${this.getComponentName(component)}: ${this.getComponentStatusText(componentStatus.status)}`);
              }
            });
          }
        }
      } else {
        this.systemState.overallHealth = 'unknown';
        this.systemState.issues = [];
      }
            
            // Extraer recomendaciones usando destructuring
      const { recommendations = [] } = data || {};
      this.systemState.recommendations = recommendations;
            
            // Actualizar indicadores visuales
      this.updateHealthIndicators(data);
    },
        
        // Obtener m√©tricas completas del sistema usando MemoryManager expandido
    getCompleteSystemMetrics() {
      return new Promise((resolve, reject) => {
        AjaxManager.call('mia_get_complete_system_metrics', {},
                    function(response) {
                      if (response.success) {
                        resolve(response.data);
                      } else {
                        reject(new Error((response.data && response.data.message) || 'Error al obtener m√©tricas'));
                      }
                    },
                    function(xhr, status, error) {
                      reject(new Error('Error de conexi√≥n: ' + error));
                    }
                );
      });
    },
        
        // Mostrar m√©tricas adicionales en el dashboard
    displayAdditionalMetrics(metrics) {
            // Crear secci√≥n de m√©tricas adicionales si no existe
      let $additionalMetrics = jQuery('#additional-system-metrics');
      if ($additionalMetrics.length === 0) {
        $additionalMetrics = jQuery('<div id="additional-system-metrics" class="mi-additional-metrics"></div>');
        jQuery('.mi-diagnostic-actions').after($additionalMetrics);
      }
            
      let html = '<h2>M√©tricas Detalladas del Sistema</h2>';
      html += '<div class="metrics-grid">';
            
            // M√©tricas de base de datos
      if (metrics && typeof metrics === 'object' && 'database' in metrics && metrics.database) {
                // Extraer propiedades usando destructuring con valores por defecto
        const database = metrics.database;
        const { 
                    total_posts = '0', 
                    total_products = '0', 
                    total_orders = '0',
                    table_sizes = {}
                } = database;
                
        html += '<div class="metric-section database">';
        html += '<h3>Base de Datos</h3>';
        html += `<p><strong>Total Posts:</strong> ${total_posts}</p>`;
        html += `<p><strong>Productos:</strong> ${total_products}</p>`;
        html += `<p><strong>Pedidos:</strong> ${total_orders}</p>`;
                
        if (table_sizes && typeof table_sizes === 'object' && Object.keys(table_sizes).length > 0) {
          html += '<p><strong>Tama√±os de Tablas:</strong></p><ul>';
          Object.entries(table_sizes).forEach(([table, size]) => {
            html += `<li>${table}: ${size} MB</li>`;
          });
          html += '</ul>';
        }
        html += '</div>';
      }
            
            // M√©tricas del sistema de archivos
      if (metrics && typeof metrics === 'object' && 'filesystem' in metrics && metrics.filesystem) {
                // Extraer propiedades usando destructuring con valores por defecto
        const filesystem = metrics.filesystem;
        const { 
                    disk_total_gb = '0', 
                    disk_used_gb = '0', 
                    disk_usage_percentage = '0',
                    disk_free_gb = '0',
                    directory_sizes = {}
                } = filesystem;
                
        html += '<div class="metric-section filesystem">';
        html += '<h3>Sistema de Archivos</h3>';
        html += `<p><strong>Disco Total:</strong> ${disk_total_gb} GB</p>`;
        html += `<p><strong>Disco Usado:</strong> ${disk_used_gb} GB (${disk_usage_percentage}%)</p>`;
        html += `<p><strong>Disco Libre:</strong> ${disk_free_gb} GB</p>`;
                
        if (directory_sizes && typeof directory_sizes === 'object' && Object.keys(directory_sizes).length > 0) {
          html += '<p><strong>Tama√±os de Directorios:</strong></p><ul>';
          Object.entries(directory_sizes).forEach(([dir, info]) => {
            if (info && info.exists) {
                            // Extraer propiedades usando destructuring con valores por defecto
              const { size_mb = '0' } = info;
              html += `<li>${dir}: ${size_mb} MB</li>`;
            }
          });
          html += '</ul>';
        }
        html += '</div>';
      }
            
            // M√©tricas de rendimiento
      if (metrics && typeof metrics === 'object' && 'performance' in metrics && metrics.performance) {
                // Extraer propiedades usando destructuring con valores por defecto
        const performance = metrics.performance;
        const { 
                    php_version = 'Unknown', 
                    wordpress_version = 'Unknown', 
                    plugin_version = 'Unknown',
                    memory_limit = 'Unknown',
                    scheduled_tasks = '0',
                    transients_count = '0'
                } = performance;
                
        html += '<div class="metric-section performance">';
        html += '<h3>Rendimiento del Sistema</h3>';
        html += `<p><strong>PHP:</strong> ${php_version}</p>`;
        html += `<p><strong>WordPress:</strong> ${wordpress_version}</p>`;
        html += `<p><strong>Plugin:</strong> ${plugin_version}</p>`;
        html += `<p><strong>L√≠mite de Memoria:</strong> ${memory_limit}</p>`;
        html += `<p><strong>Tareas Programadas:</strong> ${scheduled_tasks}</p>`;
        html += `<p><strong>Transients:</strong> ${transients_count}</p>`;
        html += '</div>';
      }
            
      html += '</div>';
            
      $additionalMetrics.html(html);
    },
        
        // Mostrar estado de cron jobs en el dashboard
    displayCronStatus(cronJobs) {
            // Crear secci√≥n de estado de cron jobs si no existe
      let $cronStatus = $('#cron-jobs-status');
      if ($cronStatus.length === 0) {
        $cronStatus = $('<div id="cron-jobs-status" class="mi-cron-status"></div>');
        $('.mi-diagnostic-actions').after($cronStatus);
      }
            
      let html = '<h2>Estado de Cron Jobs del Plugin</h2>';
      html += '<table class="wp-list-table widefat fixed striped">';
      html += '<thead><tr>';
      html += '<th>Hook</th>';
      html += '<th>Descripci√≥n</th>';
      html += '<th>Estado</th>';
      html += '<th>Pr√≥xima Ejecuci√≥n</th>';
      html += '<th>Timestamp</th>';
      html += '</tr></thead>';
      html += '<tbody>';
            
      Object.entries(cronJobs).forEach(([hook, data]) => {
                // Extraer propiedades usando destructuring con valores por defecto
        const { 
                    scheduled = false, 
                    next_run = null, 
                    timestamp = null,
                    description = 'Sin descripci√≥n'
                } = data;
                
        const statusClass = scheduled ? 'status-ok' : 'status-error';
        const statusText = scheduled ? 'Programado' : 'No Programado';
        const nextRun = scheduled ? next_run : 'N/A';
        const timestampFormatted = timestamp ? new Date(timestamp * 1000).toLocaleString() : 'N/A';
                
        html += '<tr>';
        html += `<td><code>${hook}</code></td>`;
        html += `<td>${description}</td>`;
        html += `<td><span class="${statusClass}">${statusText}</span></td>`;
        html += `<td>${nextRun}</td>`;
        html += `<td>${timestampFormatted}</td>`;
        html += '</tr>';
      });
            
      html += '</tbody></table>';
      html += '</div>';
            
      $cronStatus.html(html);
    },
        
        // CORRECCI√ìN DE OPTIMIZACI√ìN: M√©todos para funcionalidades bajo demanda
        
        // Ejecutar diagn√≥stico del sistema
    executeSystemDiagnostic() {
      const $btn = jQuery('#execute-system-diagnostic');
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Ejecutando...');
          
      AjaxManager.call('mia_execute_system_diagnostic', {}, function(response) {
        if (response.success) {
          this.displaySystemDiagnostic(response.data.diagnostic);
        }
        $btn.prop('disabled', false).html('Ejecutar Diagn√≥stico');
      }, function(xhr, status, error) {
        $btn.prop('disabled', false).html('Ejecutar Diagn√≥stico');
        ErrorHandler.showConnectionError(xhr);
        console.error(`Error en diagn√≥stico del sistema [${status}]:`, error);
      });
    },
        
        // Inicializar sistema de assets
    initializeAssets() {
      AjaxManager.call('mia_initialize_assets', {});
    },
        
        // Inicializar sistema de AJAX
    initializeAjax() {
      AjaxManager.call('mia_initialize_ajax', {});
    },
        
        // Inicializar sistema de configuraci√≥n
    initializeSettings() {
      AjaxManager.call('mia_initialize_settings', {});
    },
        
        // Inicializar sistema de limpieza
    initializeCleanup() {
      AjaxManager.call('mia_initialize_cleanup', {});
    },
        
        // Cargar textdomain del plugin
    loadTextdomain() {
      AjaxManager.call('mia_load_textdomain', {});
    },
        
        // Mostrar diagn√≥stico del sistema
    displaySystemDiagnostic(diagnostic) {
      let $diagnosticArea = jQuery('#system-diagnostic-results');
      if ($diagnosticArea.length === 0) {
        $diagnosticArea = jQuery('<div id="system-diagnostic-results" class="mi-system-diagnostic"></div>');
        jQuery('.mi-diagnostic-actions').after($diagnosticArea);
      }
            
      let html = '<h2>Diagn√≥stico del Sistema</h2>';
      html += '<div class="diagnostic-grid">';
            
            // Informaci√≥n general
      html += '<div class="diagnostic-section general">';
      html += '<h3>Informaci√≥n General</h3>';
      html += `<p><strong>Timestamp:</strong> ${diagnostic.timestamp}</p>`;
            
            // Extraer propiedades usando destructuring con valores por defecto
      const { 
                memory_usage = 0, 
                peak_memory = 0
            } = diagnostic;
            
      html += `<p><strong>Memoria Actual:</strong> ${this.formatBytes(memory_usage)}</p>`;
      html += `<p><strong>Memoria Pico:</strong> ${this.formatBytes(peak_memory)}</p>`;
      html += '</div>';
            
            // Estado de hooks
      html += '<div class="diagnostic-section hooks">';
      html += '<h3>Estado de Hooks</h3>';
            
            // Extraer propiedades usando destructuring con valores por defecto
      const { hooks_status = {} } = diagnostic;
            
      Object.entries(hooks_status).forEach(([hook, count]) => {
        const statusClass = count > 0 ? 'status-ok' : 'status-error';
        const statusText = count > 0 ? `${count} acciones` : 'Sin acciones';
        html += `<p><strong>${hook}:</strong> <span class="${statusClass}">${statusText}</span></p>`;
      });
      html += '</div>';
            
            // Estado del plugin
      html += '<div class="diagnostic-section plugin">';
      html += '<h3>Estado del Plugin</h3>';
            
            // Extraer propiedades usando destructuring con valores por defecto
      const { plugin_status = {} } = diagnostic;
      const { 
                initialized = false, 
                woocommerce_ready = false, 
                logger_available = false
            } = plugin_status;
            
      html += `<p><strong>Inicializado:</strong> <span class="${initialized ? 'status-ok' : 'status-error'}">${initialized ? 'S√≠' : 'No'}</span></p>`;
      html += `<p><strong>WooCommerce:</strong> <span class="${woocommerce_ready ? 'status-ok' : 'status-error'}">${woocommerce_ready ? 'Listo' : 'No disponible'}</span></p>`;
      html += `<p><strong>Logger:</strong> <span class="${logger_available ? 'status-ok' : 'status-error'}">${logger_available ? 'Disponible' : 'No disponible'}</span></p>`;
      html += '</div>';
            
            // Clases del core
      html += '<div class="diagnostic-section core">';
      html += '<h3>Clases del Core</h3>';
            
            // Extraer propiedades usando destructuring con valores por defecto
      const { core_classes_available = {} } = plugin_status;
            
      Object.entries(core_classes_available).forEach(([class_name, available]) => {
        const statusClass = available ? 'status-ok' : 'status-error';
        const statusText = available ? 'Disponible' : 'No disponible';
        html += `<p><strong>${class_name}:</strong> <span class="${statusClass}">${statusText}</span></p>`;
      });
      html += '</div>';
            
      html += '</div>';
            
      $diagnosticArea.html(html);
    },
        
        // Formatear bytes en formato legible
    formatBytes(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    },
        
        // Inicializar reportes de compatibilidad
    initializeCompatibilityReports() {
      AjaxManager.call('mia_initialize_compatibility_reports', {}, 
                (response) => {
                  if (response.success) {
                    this.displayCompatibilityResult(response.data, 'reports');
                  }
                }
            );
    },
        
        // Inicializar compatibilidad con temas
    initializeThemeCompatibility() {
      AjaxManager.call('mia_initialize_theme_compatibility', {}, 
                (response) => {
                  if (response.success) {
                    this.displayCompatibilityResult(response.data, 'themes');
                  }
                }
            );
    },
        
        // Inicializar compatibilidad con plugins de WooCommerce
    initializeWooCommercePluginCompatibility() {
      AjaxManager.call('mia_initialize_woocommerce_plugin_compatibility', {}, 
                (response) => {
                  if (response.success) {
                    this.displayCompatibilityResult(response.data, 'woocommerce_plugins');
                  }
                }
            );
    },
        
        // Inicializar compatibilidad general
    initializeGeneralCompatibility() {
      AjaxManager.call('mia_initialize_general_compatibility', {}, 
                (response) => {
                  if (response.success) {
                    this.displayCompatibilityResult(response.data, 'general');
                  }
                }
            );
    },
        
        // Ejecutar verificaci√≥n completa de compatibilidad
    executeCompleteCompatibilityCheck() {
      AjaxManager.call('mia_execute_complete_compatibility_check', {}, 
                (response) => {
                  if (response.success) {
                    this.displayCompleteCompatibilityResult(response.data);
                  }
                }
            );
    },
        
        // Mostrar resultado de compatibilidad individual
    displayCompatibilityResult(data, type) {
      let $resultArea = jQuery(`#compatibility-${type}-results`);
      if ($resultArea.length === 0) {
        $resultArea = jQuery(`<div id="compatibility-${type}-results" class="mi-compatibility-result"></div>`);
        jQuery('.mi-diagnostic-actions').after($resultArea);
      }
            
      let html = `<h3>Resultado de Compatibilidad: ${this.getCompatibilityTypeName(type)}</h3>`;
      html += '<div class="compatibility-details">';
            
      if (data && typeof data === 'object' && 'success' in data && data.success) {
        html += '<div class="status-success">‚úÖ Inicializaci√≥n exitosa</div>';
                
                // Extraer componentes usando destructuring
        const { components = [] } = data;
        if (components && components.length > 0) {
          html += '<p><strong>Componentes inicializados:</strong></p><ul>';
          components.forEach(component => {
            html += `<li>${component}</li>`;
          });
          html += '</ul>';
        }
      } else {
        html += '<div class="status-error">‚ùå Error en la inicializaci√≥n</div>';
                
                // Extraer errores usando destructuring
        const { errors = [] } = data || {};
        if (errors && errors.length > 0) {
          html += '<p><strong>Errores:</strong></p><ul>';
          errors.forEach(error => {
            html += `<li>${error}</li>`;
          });
          html += '</ul>';
        }
      }
            
            // Extraer advertencias usando destructuring
      const { warnings = [] } = data || {};
      if (warnings && warnings.length > 0) {
        html += '<p><strong>Advertencias:</strong></p><ul>';
        warnings.forEach(warning => {
          html += `<li>‚ö†Ô∏è ${warning}</li>`;
        });
        html += '</ul>';
      }
            
      html += '</div>';
            
      $resultArea.html(html);
    },
        
        // Mostrar resultado completo de compatibilidad
    displayCompleteCompatibilityResult(data) {
      let $resultArea = jQuery('#complete-compatibility-results');
      if ($resultArea.length === 0) {
        $resultArea = jQuery('<div id="complete-compatibility-results" class="mi-complete-compatibility-result"></div>');
        jQuery('.mi-diagnostic-actions').after($resultArea);
      }
            
      let html = '<h3>Resultado Completo de Compatibilidad</h3>';
      html += '<div class="compatibility-summary">';
            
            // Resumen general
      html += '<div class="summary-overview">';
      html += `<p><strong>Timestamp:</strong> ${data.timestamp}</p>`;
            
            // Extraer propiedades usando destructuring
      const { 
                overall_success = false, 
                summary = {}
            } = data;
            
      const { 
                total_checks = '0', 
                successful_checks = '0', 
                failed_checks = '0', 
                warnings = '0'
            } = summary;
            
      html += `<p><strong>Estado General:</strong> <span class="${overall_success ? 'status-success' : 'status-error'}">${overall_success ? '‚úÖ Exitoso' : '‚ùå Con errores'}</span></p>`;
      html += `<p><strong>Total de verificaciones:</strong> ${total_checks}</p>`;
      html += `<p><strong>Verificaciones exitosas:</strong> <span class="status-success">${successful_checks}</span></p>`;
      html += `<p><strong>Verificaciones fallidas:</strong> <span class="status-error">${failed_checks}</span></p>`;
      html += `<p><strong>Advertencias:</strong> <span class="status-warning">${warnings}</span></p>`;
      html += '</div>';
            
            // Detalles por componente
      html += '<div class="component-details">';
      html += '<h4>Detalles por Componente</h4>';
            
      Object.entries(data.components).forEach(([component_type, result]) => {
        const statusClass = result.success ? 'status-success' : 'status-error';
        const statusText = result.success ? '‚úÖ Exitoso' : '‚ùå Fallido';
                
        html += `<div class="component-item ${statusClass}">`;
        html += `<h5>${this.getCompatibilityTypeName(component_type)}</h5>`;
        html += `<p><strong>Estado:</strong> <span class="${statusClass}">${statusText}</span></p>`;
                
        if (result.components && result.components.length > 0) {
          html += '<p><strong>Componentes:</strong></p><ul>';
          result.components.forEach(comp => {
            html += `<li>${comp}</li>`;
          });
          html += '</ul>';
        }
                
        if (result.errors && result.errors.length > 0) {
          html += '<p><strong>Errores:</strong></p><ul>';
          result.errors.forEach(error => {
            html += `<li>‚ùå ${error}</li>`;
          });
          html += '</ul>';
        }
                
        if (result.warnings && result.warnings.length > 0) {
          html += '<p><strong>Advertencias:</strong></p><ul>';
          result.warnings.forEach(warning => {
            html += `<li>‚ö†Ô∏è ${warning}</li>`;
          });
          html += '</ul>';
        }
                
        html += '</div>';
      });
            
      html += '</div>';
      html += '</div>';
            
      $resultArea.html(html);
    },
        
        // Obtener nombre legible del tipo de compatibilidad
    getCompatibilityTypeName(type) {
      const names = {
        'reports': 'Reportes de Compatibilidad',
        'themes': 'Compatibilidad con Temas',
        'woocommerce_plugins': 'Compatibilidad con Plugins WooCommerce',
        'general': 'Compatibilidad General'
      };
      return names[type] || type;
    },
        
        // Inicializar hooks de sincronizaci√≥n
    initializeSyncHooks() {
      const $btn = jQuery('#initialize-sync-hooks');
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Inicializando...');
            
      AjaxManager.call('mia_initialize_sync_hooks', {}, function(response) {
        if (response.success) {
          this.displayHookResult(response.data, 'sync_hooks');
        }
        $btn.prop('disabled', false).html('Inicializar Hooks');
      }, function(xhr, status, error) {
        $btn.prop('disabled', false).html('Inicializar Hooks');
        ErrorHandler.showConnectionError(xhr);
        console.error(`Error inicializando hooks [${status}]:`, error);
      });
    },
        
        
        // Inicializar carga perezosa AJAX
    initializeAjaxLazyLoading() {
      const $btn = jQuery('#initialize-ajax-lazy-loading');
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Inicializando...');
            
      AjaxManager.call('mia_initialize_ajax_lazy_loading', {}, function(response) {
        if (response.success) {
          this.displayHookResult(response.data, 'ajax_lazy_loading');
        }
        $btn.prop('disabled', false).html('Inicializar Carga Perezosa AJAX');
      }, function(xhr, status, error) {
        $btn.prop('disabled', false).html('Inicializar Carga Perezosa AJAX');
        ErrorHandler.showConnectionError(xhr);
        console.error(`Error inicializando carga perezosa AJAX [${status}]:`, error);
      });
    },
        
        // Ejecutar debug de batch size
    executeBatchSizeDebug() {
      const $btn = jQuery('#execute-batch-size-debug');
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Ejecutando...');
            
      AjaxManager.call('mia_execute_batch_size_debug', {}, function(response) {
        if (response.success) {
          this.displayBatchSizeDebugResult(response.data);
        }
        $btn.prop('disabled', false).html('Ejecutar Debug de Batch Size');
      }, function(xhr, status, error) {
        $btn.prop('disabled', false).html('Ejecutar Debug de Batch Size');
        ErrorHandler.showConnectionError(xhr);
        console.error(`Error ejecutando debug de batch size [${status}]:`, error);
      });
    },
        
        // Mostrar resultado de hooks adicionales
    displayHookResult(data, type) {
      let $resultArea = jQuery(`#hook-${type}-results`);
      if ($resultArea.length === 0) {
        $resultArea = jQuery(`<div id="hook-${type}-results" class="mi-hook-result"></div>`);
        jQuery('.mi-diagnostic-actions').after($resultArea);
      }
            
      let html = `<h3>Resultado de Hooks: ${this.getHookTypeName(type)}</h3>`;
      html += '<div class="hook-details">';
            
      if (data.success) {
        html += '<div class="status-success">‚úÖ Inicializaci√≥n exitosa</div>';
        if (data.components && data.components.length > 0) {
          html += '<p><strong>Componentes inicializados:</strong></p><ul>';
          data.components.forEach(component => {
            html += `<li>${component}</li>`;
          });
          html += '</ul>';
        }
      } else {
        html += '<div class="status-error">‚ùå Error en la inicializaci√≥n</div>';
        if (data.errors && data.errors.length > 0) {
          html += '<p><strong>Errores:</strong></p><ul>';
          data.errors.forEach(error => {
            html += `<li>${error}</li>`;
          });
          html += '</ul>';
        }
      }
            
      if (data.warnings && data.warnings.length > 0) {
        html += '<p><strong>Advertencias:</strong></p><ul>';
        data.warnings.forEach(warning => {
          html += `<li>‚ö†Ô∏è ${warning}</li>`;
        });
        html += '</ul>';
      }
            
      html += '</div>';
            
      $resultArea.html(html);
    },
        
        // Mostrar resultado de debug de batch size
    displayBatchSizeDebugResult(data) {
      let $resultArea = jQuery('#batch-size-debug-results');
      if ($resultArea.length === 0) {
        $resultArea = jQuery('<div id="batch-size-debug-results" class="mi-batch-size-debug-result"></div>');
        jQuery('.mi-diagnostic-actions').after($resultArea);
      }
            
      let html = '<h3>Resultado de Debug de Batch Size</h3>';
      html += '<div class="batch-size-debug-details">';
            
      if (data.success) {
        html += '<div class="status-success">‚úÖ Debug ejecutado exitosamente</div>';
        if (data.components && data.components.length > 0) {
          html += '<p><strong>Componentes procesados:</strong></p><ul>';
          data.components.forEach(component => {
            html += `<li>${component}</li>`;
          });
          html += '</ul>';
        }
                
                // Extraer propiedades usando destructuring con valores por defecto
        const { debug_info = {} } = data;
                
        if (debug_info && Object.keys(debug_info).length > 0) {
          html += '<p><strong>Informaci√≥n de Debug:</strong></p><div class="debug-info-grid">';
          Object.entries(debug_info).forEach(([key, value]) => {
            html += `<div class="debug-info-item"><strong>${key}:</strong> ${value}</div>`;
          });
          html += '</div>';
        }
      } else {
        html += '<div class="status-error">‚ùå Error en la ejecuci√≥n del debug</div>';
        if (data.errors && data.errors.length > 0) {
          html += '<p><strong>Errores:</strong></p><ul>';
          data.errors.forEach(error => {
            html += `<li>${error}</li>`;
          });
          html += '</ul>';
        }
      }
            
      if (data.warnings && data.warnings.length > 0) {
        html += '<p><strong>Advertencias:</strong></p><ul>';
        data.warnings.forEach(warning => {
          html += `<li>‚ö†Ô∏è ${warning}</li>`;
        });
        html += '</ul>';
      }
            
      html += '</div>';
            
      $resultArea.html(html);
    },
        
        // Obtener nombre legible del tipo de hook
    getHookTypeName(type) {
      const names = {
        'sync_hooks': 'Hooks de Sincronizaci√≥n',
        'sync_diagnostic_ajax': 'Diagn√≥stico AJAX',
        'ajax_lazy_loading': 'Carga Perezosa AJAX'
      };
      return names[type] || type;
    },
        
        // Cargar m√©tricas adicionales del sistema
    loadAdditionalMetrics() {
      const $btn = jQuery('#load-additional-metrics');
            
            // Mostrar estado de carga
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Cargando...');
            
      this.getCompleteSystemMetrics()
                .then((metrics) => {
                  this.displayAdditionalMetrics(metrics);
                  this.showSuccess('M√©tricas adicionales cargadas correctamente');
                    
                    // Cambiar bot√≥n a "Refrescar"
                  $btn.prop('disabled', false)
                        .html('<span class="dashicons dashicons-update"></span> Refrescar M√©tricas')
                        .attr('id', 'refresh-additional-metrics');
                    
                    // Cambiar manejador del evento
                  jQuery(document).off('click', '#load-additional-metrics');
                  jQuery(document).on('click', '#refresh-additional-metrics', (e) => {
                    e.preventDefault();
                    this.loadAdditionalMetrics();
                  });
                })
                .catch((error) => {
                  this.showError('Error al cargar m√©tricas: ' + error.message);
                  $btn.prop('disabled', false)
                        .html('<span class="dashicons dashicons-update-alt"></span> Cargar M√©tricas Adicionales');
                });
    },
        
        // Verificar estado de cron jobs del plugin
    checkCronStatus() {
      const $btn = jQuery('#check-cron-status');
      $btn.prop('disabled', true).html('<span class="dashicons dashicons-update-alt"></span> Verificando...');
            
      AjaxManager.call('mia_check_cron_status', {}, function(response) {
        if (response.success) {
                // Extraer propiedades usando destructuring con valores por defecto
          const { cron_jobs = {} } = response.data || {};
          this.displayCronStatus(cron_jobs);
        }
        $btn.prop('disabled', false).html('Verificar Estado de Cron Jobs');
      }, function(xhr, status, error) {
        $btn.prop('disabled', false).html('Verificar Estado de Cron Jobs');
        ErrorHandler.showConnectionError(xhr);
        console.error(`Error verificando estado de cron jobs [${status}]:`, error);
      });
    },
        
        // Obtener texto de estado de salud
    getHealthStatusText(status) {
      const statusMap = {
        'healthy': 'Saludable',
        'attention': 'Atenci√≥n',
        'warning': 'Advertencia',
        'critical': 'Cr√≠tico',
        'error': 'Error'
      };
      return statusMap[status] || status;
    },
        
        // Obtener nombre del componente
    getComponentName(component) {
      const componentMap = {
        'memory': 'Memoria',
        'retry': 'Reintentos',
        'sync': 'Sincronizaci√≥n',
        'api': 'API'
      };
      return componentMap[component] || component;
    },
        
        // Obtener texto de estado del componente
    getComponentStatusText(status) {
      const statusMap = {
        'healthy': 'Saludable',
        'attention': 'Atenci√≥n',
        'warning': 'Advertencia',
        'critical': 'Cr√≠tico',
        'error': 'Error',
        'unavailable': 'No disponible'
      };
      return statusMap[status] || status;
    },
        
        // Obtener texto de estado de memoria
    getMemoryStatusText(status) {
      const statusMap = {
        'healthy': 'Saludable',
        'attention': 'Atenci√≥n',
        'warning': 'Advertencia',
        'critical': 'Cr√≠tico',
        'error': 'Error',
        'unavailable': 'No disponible'
      };
      return statusMap[status] || status;
    },
        
        // Obtener texto de estado de reintentos
    getRetryStatusText(status) {
      const statusMap = {
        'excellent': 'Excelente',
        'good': 'Bueno',
        'fair': 'Regular',
        'poor': 'Pobre',
        'no_data': 'Sin datos'
      };
      return statusMap[status] || status;
    },
        
        // Obtener texto de estado de sincronizaci√≥n
    getSyncStatusText(status) {
      const statusMap = {
        'running': 'En progreso',
        'syncing': 'Sincronizando',
        'completed': 'Completada',
        'failed': 'Fall√≥',
        'paused': 'Pausada',
        'unknown': 'Desconocido',
        'error': 'Error'
      };
      return statusMap[status] || status;
    },
        
        // Obtener texto de prioridad
    getPriorityText(priority) {
      const priorityMap = {
        'critical': 'Cr√≠tico',
        'high': 'Alto',
        'medium': 'Medio',
        'low': 'Bajo'
      };
      return priorityMap[priority] || priority;
    },
        
        // Mostrar mensaje de √©xito
    showSuccess(message) {
      this.showMessage(message, 'success');
    },
        
        // Mostrar mensaje de error
    showError(message) {
      this.showMessage(message, 'error');
    },
        
        // Mostrar mensaje
    showMessage(message, type = 'info') {
      if (typeof jQuery === 'undefined' || !jQuery.fn || !jQuery.fn.prependTo) {
                // Fallback si jQuery no est√° disponible
        ErrorHandler.showCriticalError(message, 'FALLBACK');
        return;
      }
            
      try {
        const $message = jQuery('<div class="notice notice-' + type + ' is-dismissible"></div>');
        $message.html('<p>' + message + '</p>');
                
                // Verificar que prependTo existe antes de usarlo
        if (typeof $message.prependTo === 'function') {
          $message.prependTo('.wrap');
        } else {
                    // Fallback: usar appendTo o insertBefore
          const $wrap = jQuery('.wrap');
          if ($wrap.length > 0) {
            $wrap.prepend($message);
          } else {
                        // √öltimo recurso: insertar al principio del body
            jQuery('body').prepend($message);
          }
        }
                
                // Auto-ocultar despu√©s de 5 segundos
        setTimeout(() => {
          if ($message && typeof $message.fadeOut === 'function') {
            $message.fadeOut(function() {
              $message.remove();
            });
          } else {
            $message.remove();
          }
        }, 5000);
      } catch (error) {
        ErrorHandler.logError('Error al mostrar mensaje', 'MESSAGE_DISPLAY');
        ErrorHandler.showCriticalError(message, 'MESSAGE_DISPLAY');
      }
    },
        
        // Verificar si hay una sincronizaci√≥n en progreso
    isSyncInProgress() {
            // Verificar si hay polling activo de sincronizaci√≥n
      if (typeof pollingManager !== 'undefined' && pollingManager.isPollingActive('syncProgress')) {
        return true;
      }
            
            // Verificar si hay un intervalo de sincronizaci√≥n activo
      if (typeof syncInterval !== 'undefined' && syncInterval !== null) {
        return true;
      }
            
            // Verificar elementos del DOM una sola vez
      const $syncBtn = jQuery('#mi-batch-sync-products');
      const $feedback = jQuery('#mi-sync-feedback');
            
      return (
                // Verificar si el bot√≥n de sincronizaci√≥n est√° deshabilitado (indicador de progreso)
                ($syncBtn.length && $syncBtn.is(':disabled')) ||
                // Verificar si hay feedback de progreso visible
                ($feedback.length && $feedback.hasClass('in-progress'))
            );
    }
  };
    
    // Exponer globalmente para uso manual
  if (typeof window !== 'undefined') {
    try {
            // Asignar a window.UnifiedDashboard
      window.UnifiedDashboard = UnifiedDashboard;
    } catch (error) {
            // Si falla, usar defineProperty como alternativa
      Object.defineProperty(window, 'UnifiedDashboard', {
        value: UnifiedDashboard,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
    
    // Exponer tambi√©n directamente para uso sin window.
    // Esto permite usar UnifiedDashboard.init() directamente como en la documentaci√≥n
  if (typeof globalThis !== 'undefined') {
    globalThis.UnifiedDashboard = UnifiedDashboard;
  } else if (typeof global !== 'undefined') {
    global.UnifiedDashboard = UnifiedDashboard;
  } else if (typeof window !== 'undefined') {
        // Para navegadores, usar una funci√≥n que exponga la variable
    (function() {
            // Crear una variable global directa
      const globalScope = (function() { return this; })();
      if (globalScope) {
        globalScope.UnifiedDashboard = UnifiedDashboard;
      }
    })();
  }
    
    // ========================================
    // SISTEMA DE EVENTOS PARA CONTROL DE ORDEN
    // ========================================
    
    /**
     * ========================================
     * SYSTEM EVENT MANAGER - GESTI√ìN DE EVENTOS DEL SISTEMA
     * ========================================
     * 
     * @class SystemEventManager
     * @description Coordinaci√≥n de inicializaci√≥n de sistemas externos
     * @namespace SystemEventManager
     * 
     * @example
     * // Inicializar sistema de eventos
     * SystemEventManager.init();
     * 
     * // Registrar un sistema
     * SystemEventManager.registerSystem('miSistema', ['jQuery'], callback);
     * 
     * @since 1.0.0
     * @author Christian
     */
  const SystemEventManager = {
        // Estado de inicializaci√≥n
    initializationState: {
      systemBase: false,
      errorHandler: false,
      unifiedDashboard: false,
      allSystems: false
    },
        
        // Lista de sistemas registrados
    registeredSystems: new Map(),
        
        /**
         * Inicializar el sistema de eventos
         * @returns {void}
         * @example
         * SystemEventManager.init();
         */
    init() {
      this.log('Sistema de eventos inicializado');
      this.emitSystemBaseReady();
    },
        
        // Emitir evento de sistema base listo
    emitSystemBaseReady() {
      this.initializationState.systemBase = true;
      this.log('Sistema base listo - emitiendo evento');
      window.dispatchEvent(new CustomEvent('mi-system-base-ready', {
        detail: {
          timestamp: Date.now(),
          systems: {
            errorHandler: typeof ErrorHandler !== 'undefined',
            ajaxManager: typeof AjaxManager !== 'undefined',
            pollingManager: typeof PollingManager !== 'undefined'
          }
        }
      }));
    },
        
        // Emitir evento de ErrorHandler listo
    emitErrorHandlerReady() {
      this.initializationState.errorHandler = true;
      this.log('ErrorHandler listo - emitiendo evento');
      window.dispatchEvent(new CustomEvent('mi-error-handler-ready', {
        detail: {
          timestamp: Date.now(),
          errorHandler: typeof ErrorHandler !== 'undefined'
        }
      }));
    },
        
        // Emitir evento de UnifiedDashboard listo
    emitUnifiedDashboardReady() {
      this.initializationState.unifiedDashboard = true;
      this.log('UnifiedDashboard listo - emitiendo evento');
      window.dispatchEvent(new CustomEvent('mi-unified-dashboard-ready', {
        detail: {
          timestamp: Date.now(),
          unifiedDashboard: typeof window.UnifiedDashboard !== 'undefined'
        }
      }));
            
            // Verificar si todos los sistemas est√°n listos
      this.checkAllSystemsReady();
    },
        
        // Verificar si todos los sistemas est√°n listos
    checkAllSystemsReady() {
      const allReady = Object.values(this.initializationState).every(state => state === true);
      if (allReady && !this.initializationState.allSystems) {
        this.initializationState.allSystems = true;
        this.log('Todos los sistemas listos - emitiendo evento final');
        window.dispatchEvent(new CustomEvent('mi-all-systems-ready', {
          detail: {
            timestamp: Date.now(),
            initializationState: this.initializationState
          }
        }));
      }
    },
        
        // Registrar un sistema externo
    registerSystem(systemName, dependencies, callback) {
      this.registeredSystems.set(systemName, {
        dependencies,
        callback,
        initialized: false
      });
      this.log(`Sistema registrado: ${systemName}`);
    },
        
        // Verificar dependencias de un sistema
    checkDependencies(systemName) {
      const system = this.registeredSystems.get(systemName);
      if (!system) {
        this.log(`Sistema no encontrado: ${systemName}`, 'error');
        return false;
      }
            
      const dependencies = system.dependencies;
      const available = dependencies.every(dep => {
        if (typeof dep === 'string') {
          return typeof window[dep] !== 'undefined';
        } else if (typeof dep === 'function') {
          return dep();
        }
        return false;
      });
            
      this.log(`Dependencias de ${systemName}: ${available ? 'disponibles' : 'faltantes'}`);
      return available;
    },
        
        // Inicializar un sistema si sus dependencias est√°n disponibles
    initializeSystem(systemName) {
      const system = this.registeredSystems.get(systemName);
      if (!system || system.initialized) {
        return false;
      }
            
      if (this.checkDependencies(systemName)) {
        try {
          system.callback();
          system.initialized = true;
          this.log(`Sistema inicializado: ${systemName}`);
          return true;
        } catch (error) {
          this.log(`Error al inicializar sistema ${systemName}:`, 'error', error);
          return false;
        }
      }
            
      return false;
    },
        
        // Obtener estado de inicializaci√≥n
    getInitializationState() {
      return Object.assign({}, this.initializationState, {
        registeredSystems: Array.from(this.registeredSystems.keys()),
        systemDetails: Object.fromEntries(
                    Array.from(this.registeredSystems.entries()).map(([name, system]) => [
                      name, 
                        { initialized: system.initialized, dependencies: system.dependencies }
                    ])
                )
      });
    },
        
        // Logging del sistema de eventos
    log(message, level = 'info', data = null) {
      const timestamp = new Date().toISOString();
      const logMessage = `[SystemEventManager ${timestamp}] ${message}`;
            
      if (level === 'error') {
        console.error(logMessage, data);
      } else if (level === 'warn') {
        console.warn(logMessage, data);
      } else {
        console.log(logMessage, data);
      }
    }
  };
    
    // Exponer globalmente el sistema de eventos
  if (typeof window !== 'undefined') {
    try {
            // Asignar a window.SystemEventManager
      window.SystemEventManager = SystemEventManager;
    } catch (error) {
            // Si falla, usar defineProperty como alternativa
      Object.defineProperty(window, 'SystemEventManager', {
        value: SystemEventManager,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
    
    // Exponer tambi√©n directamente para uso sin window.
    // Esto permite usar SystemEventManager.init() directamente como en la documentaci√≥n
  if (typeof globalThis !== 'undefined') {
    globalThis.SystemEventManager = SystemEventManager;
  } else if (typeof global !== 'undefined') {
    global.SystemEventManager = SystemEventManager;
  } else if (typeof window !== 'undefined') {
        // Para navegadores, usar una funci√≥n que exponga la variable
    (function() {
            // Crear una variable global directa
      const globalScope = (function() { return this; })();
      if (globalScope) {
        globalScope.SystemEventManager = SystemEventManager;
      }
    })();
  }
    
    // ========================================
    // INICIALIZACI√ìN DEL SISTEMA DE EVENTOS
    // ========================================
    
    // Inicializar el sistema de eventos cuando el DOM est√© listo
  jQuery(document).ready(function() {
      // Emitir eventos de inicializaci√≥n en orden
    SystemEventManager.init();
    SystemEventManager.emitErrorHandlerReady();
    SystemEventManager.emitUnifiedDashboardReady();
      
      // Log del estado final
    setTimeout(function() {
      const state = SystemEventManager.getInitializationState();
      SystemEventManager.log('Estado final de inicializaci√≥n:', 'info', state);
    }, 1000);
  });       
    
    // ========================================
    // SISTEMA DE LAYOUT RESPONSIVE
    // ========================================
    
    /**
     * Sistema de layout responsive para el dashboard
     * 
     * @namespace ResponsiveLayout
     * @description Gestiona el layout responsive del dashboard
     * @since 1.0.0
     */
  const ResponsiveLayout = {
    timeout: null,
        
        /**
         * Ajusta el layout basado en el tama√±o de la ventana
         * @function adjustLayout
         * @returns {void}
         */
    adjustLayout() {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(() => {
        const $sidebar = jQuery('.mi-integracion-api-sidebar');
                
                // Ajustar sidebar en m√≥viles
        if (window.innerWidth < 769) {
                    // Remover estilos sticky y ajustar altura
          $sidebar.css({
            'position': 'relative',
            'top': 'auto',
            'height': 'auto',
            'max-height': 'none'
          });
        } else {
                    // Restaurar estilos sticky para desktop
          $sidebar.css({
            'position': 'sticky',
            'top': '20px',
            'height': 'fit-content',
            'max-height': 'none'
          });
        }
                
                // Ajustar grid de estad√≠sticas basado en tama√±o real
        const statsGrid = jQuery('.mi-integracion-api-stats-grid');
        const gridWidth = statsGrid.width();
                
        if (gridWidth < 400) {
          statsGrid.addClass('single-column');
        } else if (gridWidth < 600) {
          statsGrid.addClass('two-columns');
        } else if (gridWidth < 900) {
          statsGrid.addClass('three-columns');
        } else {
          statsGrid.removeClass('single-column two-columns three-columns');
        }
      }, 100);
    },
        
        /**
         * Inicializa el men√∫ responsive
         * @function initResponsiveMenu
         * @returns {void}
         */
    initResponsiveMenu() {
      const $menu = jQuery('.mi-integracion-api-nav-menu ul');
            
      if (window.innerWidth < 577) {
                // A√±adir indicador de scroll horizontal
        $menu.addClass('scrollable-horizontal');
      } else {
        $menu.removeClass('scrollable-horizontal');
      }
    },
        
        /**
         * Inicializa el sistema responsive
         * @function init
         * @returns {void}
         */
    init() {
      const self = this;
            
            // Ejecutar al cargar y al redimensionar
      jQuery(document).ready(function() {
        self.adjustLayout();
        self.initResponsiveMenu();
      });
            
      jQuery(window).resize(function() {
        self.adjustLayout();
        self.initResponsiveMenu();
      });
            
      jQuery(window).on('orientationchange', function() {
                // Peque√±o delay para que el navegador ajuste las dimensiones
        setTimeout(function() {
          self.adjustLayout();
          self.initResponsiveMenu();
        }, 100);
      });
    }
  };
    
    // Inicializar el sistema responsive
  ResponsiveLayout.init();
    
    // Exponer globalmente el sistema responsive
  if (typeof window !== 'undefined') {
    try {
            // Asignar a window.ResponsiveLayout
      window.ResponsiveLayout = ResponsiveLayout;
    } catch (error) {
            // Si falla, usar defineProperty como alternativa
      Object.defineProperty(window, 'ResponsiveLayout', {
        value: ResponsiveLayout,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
    
    // Exponer tambi√©n directamente para uso sin window.
    // Esto permite usar ResponsiveLayout.init() directamente como en la documentaci√≥n
  if (typeof globalThis !== 'undefined') {
    globalThis.ResponsiveLayout = ResponsiveLayout;
  } else if (typeof global !== 'undefined') {
    global.ResponsiveLayout = ResponsiveLayout;
  } else if (typeof window !== 'undefined') {
        // Para navegadores, usar una funci√≥n que exponga la variable
    (function() {
            // Crear una variable global directa
      const globalScope = (function() { return this; })();
      if (globalScope) {
        globalScope.ResponsiveLayout = ResponsiveLayout;
      }
    })();
  }
    
    // Log simple de inicializaci√≥n exitosa
    
    // ========================================
    // CONTROLADOR PRINCIPAL DEL DASHBOARD
    // ========================================
    
    /**
     * Controlador principal del dashboard
     * 
     * Coordina la inicializaci√≥n y gesti√≥n de todos los sistemas del dashboard:
     * - UnifiedDashboard: Diagn√≥stico y m√©tricas del sistema
     * - SyncDashboard: Sincronizaci√≥n en dos fases
     * - SystemEventManager: Gesti√≥n de eventos del sistema
     * - ResponsiveLayout: Layout responsive
     * - PollingManager: Gesti√≥n de polling
     * - ErrorHandler: Manejo de errores
     * - AjaxManager: Gesti√≥n de peticiones AJAX
     * 
     * @class UnifiedDashboardController
     * @namespace UnifiedDashboardController
     * @description Controlador principal que coordina todos los sistemas del dashboard
     * 
     * @example
     * // Inicializar el controlador (se ejecuta autom√°ticamente)
     * UnifiedDashboardController.init();
     * 
     * // Toggle del sidebar
     * UnifiedDashboardController.toggleSidebar();
     * 
     * @since 1.0.0
     * @author Christian
     */
  const UnifiedDashboardController = {
      // Variables de estado
    isSidebarVisible: true,
    lastSyncedData: null,
    initialized: false,
    systems: {
      unifiedDashboard: false,
      syncDashboard: false,
      systemEventManager: false,
      responsiveLayout: false,
      pollingManager: false,
      errorHandler: false,
      ajaxManager: false
    },
      
      /**
       * Inicializar el controlador principal
       * @function init
       * @returns {void}
       * @description Coordina la inicializaci√≥n de todos los sistemas del dashboard
       */
    init() {
      if (this.initialized) {
        console.warn('UnifiedDashboardController ya est√° inicializado');
        return;
      }
        
      console.log('üéØ Inicializando UnifiedDashboardController...');
        
        // 1. Inicializar sistemas base (orden cr√≠tico)
      this.initBaseSystems();
        
        // 2. Inicializar eventos del sidebar
      this.initSidebar();
        
        // 3. Inicializar eventos de la vista global
      this.initGlobalView();
        
        // 4. Inicializar sistemas de alto nivel
      this.initHighLevelSystems();
        
        // 5. Cargar datos iniciales
      this.loadData();
        
      this.initialized = true;
      console.log('‚úÖ UnifiedDashboardController inicializado correctamente');
    },
      
      /**
       * Inicializar sistemas base (ErrorHandler, AjaxManager, PollingManager)
       * @function initBaseSystems
       * @returns {void}
       * @private
       */
    initBaseSystems() {
      console.log('üîß Inicializando sistemas base...');
        
        // ErrorHandler ya est√° disponible globalmente
      if (typeof ErrorHandler !== 'undefined') {
        this.systems.errorHandler = true;
        console.log('  ‚úÖ ErrorHandler disponible');
      }
        
        // AjaxManager ya est√° disponible globalmente
      if (typeof window.AjaxManager !== 'undefined') {
        this.systems.ajaxManager = true;
        console.log('  ‚úÖ AjaxManager disponible');
      }
        
        // PollingManager ya est√° disponible globalmente
      if (typeof pollingManager !== 'undefined') {
        this.systems.pollingManager = true;
        console.log('  ‚úÖ PollingManager disponible');
      }
    },
      
      /**
       * Inicializar sistemas de alto nivel (UnifiedDashboard, SyncDashboard, etc.)
       * @function initHighLevelSystems
       * @returns {void}
       * @private
       */
    initHighLevelSystems() {
      console.log('üöÄ Inicializando sistemas de alto nivel...');
        
        // UnifiedDashboard
      if (typeof window.UnifiedDashboard !== 'undefined') {
        try {
          window.UnifiedDashboard.init();
          this.systems.unifiedDashboard = true;
          console.log('  ‚úÖ UnifiedDashboard inicializado');
        } catch (error) {
          console.error('  ‚ùå Error inicializando UnifiedDashboard:', error);
        }
      }
        
        // SyncDashboard (se inicializa autom√°ticamente si existe el elemento)
        // Nota: SyncDashboard se define dentro de jQuery(document).ready, 
        // por lo que verificamos window.syncDashboard en lugar de la clase
      if (jQuery('#sync-two-phase-dashboard').length) {
        try {
            // SyncDashboard ya se inicializa autom√°ticamente en l√≠nea 1925
            // Solo verificamos si est√° disponible
          if (window.syncDashboard) {
            this.systems.syncDashboard = true;
            console.log('  ‚úÖ SyncDashboard disponible');
          } else {
            console.warn('  ‚ö†Ô∏è SyncDashboard no est√° disponible a√∫n');
          }
        } catch (error) {
          console.error('  ‚ùå Error verificando SyncDashboard:', error);
        }
      }
        
        // SystemEventManager
      if (typeof window.SystemEventManager !== 'undefined') {
        try {
          window.SystemEventManager.init();
          this.systems.systemEventManager = true;
          console.log('  ‚úÖ SystemEventManager inicializado');
        } catch (error) {
          console.error('  ‚ùå Error inicializando SystemEventManager:', error);
        }
      }
        
        // ResponsiveLayout (ya se inicializa autom√°ticamente)
      if (typeof window.ResponsiveLayout !== 'undefined') {
        this.systems.responsiveLayout = true;
        console.log('  ‚úÖ ResponsiveLayout disponible');
      }
    },
      
      /**
       * Inicializar eventos del sidebar
       * @function initSidebar
       * @returns {void}
       * @private
       */
    initSidebar() {
      console.log('üìã Inicializando eventos del sidebar...');
        
        // Manejar clics en los botones del sidebar
      jQuery('.sidebar-toggle').on('click', () => {
        this.toggleSidebar();
      });
        
        // Ajustar la visibilidad inicial del sidebar
      const $sidebar = jQuery('.mi-integracion-api-sidebar');
      if ($sidebar.length) {
          // Verificar estado guardado en localStorage si existe
        const savedState = localStorage.getItem('dashboard-sidebar-visible');
        if (savedState !== null) {
          this.isSidebarVisible = savedState === 'true';
        }
          
        if (!this.isSidebarVisible) {
          this.hideSidebar();
        } else {
          this.showSidebar();
        }
      }
    },
      
      /**
       * Toggle del sidebar
       * @function toggleSidebar
       * @returns {void}
       */
    toggleSidebar() {
      console.log('üîÑ Cambiando visibilidad del sidebar...');
        
      if (this.isSidebarVisible) {
        this.hideSidebar();
      } else {
        this.showSidebar();
      }
    },
      
      /**
       * Ocultar sidebar
       * @function hideSidebar
       * @returns {void}
       */
    hideSidebar() {
      console.log('üëÅÔ∏è Ocultando sidebar...');
        
      const $sidebar = jQuery('.mi-integracion-api-sidebar');
      if ($sidebar.length) {
        $sidebar.fadeOut(300);
        this.isSidebarVisible = false;
        localStorage.setItem('dashboard-sidebar-visible', 'false');
      }
    },
      
      /**
       * Mostrar sidebar
       * @function showSidebar
       * @returns {void}
       */
    showSidebar() {
      console.log('üëÅÔ∏è Mostrando sidebar...');
        
      const $sidebar = jQuery('.mi-integracion-api-sidebar');
      if ($sidebar.length) {
        $sidebar.fadeIn(300);
        this.isSidebarVisible = true;
        localStorage.setItem('dashboard-sidebar-visible', 'true');
      }
    },
      
      /**
       * Inicializar eventos de la vista global
       * @function initGlobalView
       * @returns {void}
       * @private
       */
    initGlobalView() {
      console.log('üåê Inicializando eventos de la vista global...');
        
        // Manejar clics en los botones del encabezado
      jQuery('.global-header button').on('click', (e) => {
        this.handleHeaderClick(e);
      });
    },
      
      /**
       * Manejar clics en el encabezado
       * @function handleHeaderClick
       * @param {Event} e - Evento de click
       * @returns {void}
       * @private
       */
    handleHeaderClick(e) {
      console.log('üñ±Ô∏è Manejando clic en el encabezado...');
        
      const $button = jQuery(e.target).closest('button');
      const buttonId = $button.attr('id');
        
        // Implementar l√≥gica espec√≠fica seg√∫n el bot√≥n
      if (buttonId) {
        console.log(`  Bot√≥n clickeado: ${buttonId}`);
      }
    },
      
      /**
       * Cargar datos iniciales
       * @function loadData
       * @returns {void}
       * @private
       */
    loadData() {
      console.log('üìä Cargando datos iniciales...');
        
        // Cargar estado de sincronizaci√≥n si SyncDashboard est√° disponible
      if (this.systems.syncDashboard && window.syncDashboard) {
        window.syncDashboard.loadCurrentStatus();
      }
        
        // Cargar estado del sistema si UnifiedDashboard est√° disponible
      if (this.systems.unifiedDashboard && window.UnifiedDashboard) {
          // UnifiedDashboard carga datos bajo demanda, no autom√°ticamente
      }
        
        // Simular carga de datos adicionales
      setTimeout(() => {
        this.lastSyncedData = { 
          timestamp: new Date(),
          systems: this.systems
        };
        console.log('‚úÖ Datos cargados:', this.lastSyncedData);
          
          // Actualizar la vista con los nuevos datos
        this.updateView();
      }, 1000);
    },
      
      /**
       * Actualizar la vista del dashboard
       * @function updateView
       * @returns {void}
       * @private
       */
    updateView() {
      console.log('üîÑ Actualizando vista del dashboard...');
        
        // Actualizar indicadores de estado de sistemas
      this.updateSystemIndicators();
    },
      
      /**
       * Actualizar indicadores de estado de sistemas
       * @function updateSystemIndicators
       * @returns {void}
       * @private
       */
    updateSystemIndicators() {
        // Esta funci√≥n puede actualizar indicadores visuales del estado de los sistemas
      const totalSystems = Object.keys(this.systems).length;
      const activeSystems = Object.values(this.systems).filter(s => s === true).length;
        
      console.log(`üìà Sistemas activos: ${activeSystems}/${totalSystems}`);
    },
      
      /**
       * Obtener estado del controlador
       * @function getState
       * @returns {Object} Estado actual del controlador
       */
    getState() {
      return {
        initialized: this.initialized,
        isSidebarVisible: this.isSidebarVisible,
        lastSyncedData: this.lastSyncedData,
        systems: this.systems
      };
    },
      
      /**
       * Reinicializar el controlador
       * @function reinit
       * @returns {void}
       */
    reinit() {
      console.log('üîÑ Reinicializando UnifiedDashboardController...');
      this.initialized = false;
      this.init();
    }
  };
    
    // Exponer globalmente
  if (typeof window !== 'undefined') {
    window.UnifiedDashboardController = UnifiedDashboardController;
  }
    
    // Inicializar autom√°ticamente cuando el DOM est√© listo
  jQuery(document).ready(function() {
    UnifiedDashboardController.init();
  });
    
})();