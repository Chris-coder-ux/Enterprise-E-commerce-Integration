<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>components/SyncDashboard.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AjaxManager.html">AjaxManager</a><ul class='methods'><li data-type='method'><a href="AjaxManager.html#.call">call</a></li></ul></li><li><a href="ErrorHandler.html">ErrorHandler</a><ul class='methods'><li data-type='method'><a href="ErrorHandler.html#.logError">logError</a></li><li data-type='method'><a href="ErrorHandler.html#.showCancelError">showCancelError</a></li><li data-type='method'><a href="ErrorHandler.html#.showConnectionError">showConnectionError</a></li><li data-type='method'><a href="ErrorHandler.html#.showCriticalError">showCriticalError</a></li><li data-type='method'><a href="ErrorHandler.html#.showProtectionError">showProtectionError</a></li><li data-type='method'><a href="ErrorHandler.html#.showUIError">showUIError</a></li></ul></li><li><a href="EventCleanupManager.html">EventCleanupManager</a><ul class='methods'><li data-type='method'><a href="EventCleanupManager.html#cleanupAll">cleanupAll</a></li><li data-type='method'><a href="EventCleanupManager.html#getStats">getStats</a></li><li data-type='method'><a href="EventCleanupManager.html#.cleanupComponent">cleanupComponent</a></li><li data-type='method'><a href="EventCleanupManager.html#.getInstance">getInstance</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerCustomEventListener">registerCustomEventListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerDocumentListener">registerDocumentListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerElementListener">registerElementListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerNativeListener">registerNativeListener</a></li></ul></li><li></li><li></li><li><a href="PollingManager.html">PollingManager</a><ul class='methods'><li data-type='method'><a href="PollingManager.html#adjustPolling">adjustPolling</a></li><li data-type='method'><a href="PollingManager.html#emit">emit</a></li><li data-type='method'><a href="PollingManager.html#getIntervalId">getIntervalId</a></li><li data-type='method'><a href="PollingManager.html#isPollingActive">isPollingActive</a></li><li data-type='method'><a href="PollingManager.html#off">off</a></li><li data-type='method'><a href="PollingManager.html#on">on</a></li><li data-type='method'><a href="PollingManager.html#recordError">recordError</a></li><li data-type='method'><a href="PollingManager.html#recordResponseTime">recordResponseTime</a></li><li data-type='method'><a href="PollingManager.html#reset">reset</a></li><li data-type='method'><a href="PollingManager.html#startPolling">startPolling</a></li><li data-type='method'><a href="PollingManager.html#stopAllPolling">stopAllPolling</a></li><li data-type='method'><a href="PollingManager.html#stopPolling">stopPolling</a></li></ul></li><li></li><li></li><li><a href="SyncDashboard.html">SyncDashboard</a><ul class='methods'><li data-type='method'><a href="SyncDashboard.html#cancelPhase1">cancelPhase1</a></li><li data-type='method'><a href="SyncDashboard.html#cancelSync">cancelSync</a></li><li data-type='method'><a href="SyncDashboard.html#disableButton">disableButton</a></li><li data-type='method'><a href="SyncDashboard.html#enableButton">enableButton</a></li><li data-type='method'><a href="SyncDashboard.html#handlePhase1Response">handlePhase1Response</a></li><li data-type='method'><a href="SyncDashboard.html#loadCurrentStatus">loadCurrentStatus</a></li><li data-type='method'><a href="SyncDashboard.html#pausePhase2">pausePhase2</a></li><li data-type='method'><a href="SyncDashboard.html#resumePhase1">resumePhase1</a></li><li data-type='method'><a href="SyncDashboard.html#startPhase1">startPhase1</a></li><li data-type='method'><a href="SyncDashboard.html#startPhase2">startPhase2</a></li><li data-type='method'><a href="SyncDashboard.html#startTimer">startTimer</a></li><li data-type='method'><a href="SyncDashboard.html#stopTimer">stopTimer</a></li><li data-type='method'><a href="SyncDashboard.html#updateConfig">updateConfig</a></li><li data-type='method'><a href="SyncDashboard.html#updateDashboardFromStatus">updateDashboardFromStatus</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhase1Progress">updatePhase1Progress</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhase2Progress">updatePhase2Progress</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhaseStatus">updatePhaseStatus</a></li></ul></li><li></li><li></li><li><a href="UIOptimizer.html">UIOptimizer</a><ul class='methods'><li data-type='method'><a href="UIOptimizer.html#cancelPendingUpdates">cancelPendingUpdates</a></li><li data-type='method'><a href="UIOptimizer.html#clearCache">clearCache</a></li><li data-type='method'><a href="UIOptimizer.html#scheduleUpdate">scheduleUpdate</a></li><li data-type='method'><a href="UIOptimizer.html#.getInstance">getInstance</a></li><li data-type='method'><a href="UIOptimizer.html#.updateCssIfChanged">updateCssIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateDataIfChanged">updateDataIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateHtmlIfChanged">updateHtmlIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateTextIfChanged">updateTextIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateValueIfChanged">updateValueIfChanged</a></li></ul></li><li></li><li></li></ul><h3>Modules</h3><ul><li><a href="module-ui_SidebarController.html">ui/SidebarController</a></li><li><a href="module-utils_FormatUtils.html">utils/FormatUtils</a></li></ul><h3>Namespaces</h3><ul><li></li><li><a href="CardManager.html">CardManager</a></li><li></li><li><a href="ConsoleManager.html">ConsoleManager</a></li><li><a href="DASHBOARD_CONFIG.html">DASHBOARD_CONFIG</a></li><li></li><li><a href="global.html#DomUtils">DomUtils</a></li><li></li><li><a href="MESSAGES.html">MESSAGES</a></li><li><a href="global.html#NonceManager">NonceManager</a></li><li><a href="global.html#Phase1Manager">Phase1Manager</a></li><li><a href="global.html#Phase2Manager">Phase2Manager</a></li><li><a href="global.html#ProgressBar">ProgressBar</a></li><li><a href="ResponsiveLayout.html">ResponsiveLayout</a></li><li></li><li><a href="SELECTORS.html">SELECTORS</a></li><li></li><li><a href="global.html#Sanitizer">Sanitizer</a><ul class='methods'><li data-type='method'><a href="global.html#Sanitizer#.escapeHtml">escapeHtml</a></li><li data-type='method'><a href="global.html#Sanitizer#.sanitizeHtml">sanitizeHtml</a></li><li data-type='method'><a href="global.html#Sanitizer#.sanitizeMessage">sanitizeMessage</a></li></ul></li><li><a href="global.html#SyncController">SyncController</a></li><li><a href="global.html#SyncProgress">SyncProgress</a></li><li><a href="global.html#SyncStateManager">SyncStateManager</a></li><li><a href="global.html#SystemEventManager">SystemEventManager</a><ul class='methods'><li data-type='method'><a href="global.html#SystemEventManager#.checkAllSystemsReady">checkAllSystemsReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.checkDependencies">checkDependencies</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitErrorHandlerReady">emitErrorHandlerReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitSystemBaseReady">emitSystemBaseReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitUnifiedDashboardReady">emitUnifiedDashboardReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.getInitializationState">getInitializationState</a></li><li data-type='method'><a href="global.html#SystemEventManager#.init">init</a></li><li data-type='method'><a href="global.html#SystemEventManager#.initializeSystem">initializeSystem</a></li><li data-type='method'><a href="global.html#SystemEventManager#.log">log</a></li><li data-type='method'><a href="global.html#SystemEventManager#.registerSystem">registerSystem</a></li></ul></li><li><a href="global.html#ToastManager">ToastManager</a></li><li><a href="UnifiedDashboard.html">UnifiedDashboard</a><ul class='methods'><li data-type='method'><a href="UnifiedDashboard.html#.init">init</a></li><li data-type='method'><a href="UnifiedDashboard.html#.toggleDebugMode">toggleDebugMode</a></li></ul></li><li></li><li><a href="UnifiedDashboardController.html">UnifiedDashboardController</a></li><li></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_DURATION">DEFAULT_DURATION</a></li><li><a href="global.html#DEFAULT_RENEWAL_INTERVAL">DEFAULT_RENEWAL_INTERVAL</a></li><li><a href="global.html#DEFAULT_SELECTOR">DEFAULT_SELECTOR</a></li><li><a href="global.html#DOM_CACHE">DOM_CACHE</a></li><li><a href="global.html#TOAST_CLASSES">TOAST_CLASSES</a></li><li><a href="global.html#TOAST_COLORS">TOAST_COLORS</a></li><li><a href="global.html#TOAST_ICONS">TOAST_ICONS</a></li><li><a href="global.html#adjustLayout">adjustLayout</a></li><li><a href="global.html#attemptRenewal">attemptRenewal</a></li><li><a href="global.html#check">check</a></li><li><a href="global.html#cleanupOnPageLoad">cleanupOnPageLoad</a></li><li><a href="global.html#cleanupSyncProgressListeners">cleanupSyncProgressListeners</a></li><li><a href="global.html#clearPhase2PollingInterval">clearPhase2PollingInterval</a></li><li><a href="global.html#clearSyncInterval">clearSyncInterval</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getFadeInDuration">getFadeInDuration</a></li><li><a href="global.html#getInactiveProgressCounter">getInactiveProgressCounter</a></li><li><a href="global.html#getLastProgressValue">getLastProgressValue</a></li><li><a href="global.html#getPhase1Initialized">getPhase1Initialized</a></li><li><a href="global.html#getPhase1Starting">getPhase1Starting</a></li><li><a href="global.html#getPhase2Initialized">getPhase2Initialized</a></li><li><a href="global.html#getPhase2PollingInterval">getPhase2PollingInterval</a></li><li><a href="global.html#getPhase2ProcessingBatch">getPhase2ProcessingBatch</a></li><li><a href="global.html#getPhase2Starting">getPhase2Starting</a></li><li><a href="global.html#getPollingInterval">getPollingInterval</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#getSyncInterval">getSyncInterval</a></li><li><a href="global.html#getTrackingState">getTrackingState</a></li><li><a href="global.html#getWidth">getWidth</a></li><li><a href="global.html#hideSidebar">hideSidebar</a></li><li><a href="global.html#inactiveProgressCounter">inactiveProgressCounter</a></li><li><a href="global.html#incrementInactiveProgressCounter">incrementInactiveProgressCounter</a></li><li><a href="global.html#info">info</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initCache">initCache</a></li><li><a href="global.html#initResponsiveMenu">initResponsiveMenu</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeSyncDashboard">initializeSyncDashboard</a></li><li><a href="global.html#isAutoRenewalActive">isAutoRenewalActive</a></li><li><a href="global.html#isAvailable">isAvailable</a></li><li><a href="global.html#isCacheInitialized">isCacheInitialized</a></li><li><a href="global.html#isComplete">isComplete</a></li><li><a href="global.html#isPollingActive">isPollingActive</a></li><li><a href="global.html#phase1Starting">phase1Starting</a></li><li><a href="global.html#phase2Starting">phase2Starting</a></li><li><a href="global.html#pollingManager">pollingManager</a></li><li><a href="global.html#proceedWithSync">proceedWithSync</a></li><li><a href="global.html#processNextBatchAutomatically">processNextBatchAutomatically</a></li><li><a href="global.html#refreshCache">refreshCache</a></li><li><a href="global.html#reinit">reinit</a></li><li><a href="global.html#renewalIntervalId">renewalIntervalId</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetAllState">resetAllState</a></li><li><a href="global.html#resetCounters">resetCounters</a></li><li><a href="global.html#resetPhase1State">resetPhase1State</a></li><li><a href="global.html#resetPhase2State">resetPhase2State</a></li><li><a href="global.html#setColor">setColor</a></li><li><a href="global.html#setInactiveProgressCounter">setInactiveProgressCounter</a></li><li><a href="global.html#setLastProgressValue">setLastProgressValue</a></li><li><a href="global.html#setPercentage">setPercentage</a></li><li><a href="global.html#setPhase1Initialized">setPhase1Initialized</a></li><li><a href="global.html#setPhase1Starting">setPhase1Starting</a></li><li><a href="global.html#setPhase2Initialized">setPhase2Initialized</a></li><li><a href="global.html#setPhase2PollingInterval">setPhase2PollingInterval</a></li><li><a href="global.html#setPhase2ProcessingBatch">setPhase2ProcessingBatch</a></li><li><a href="global.html#setPhase2Starting">setPhase2Starting</a></li><li><a href="global.html#setSyncInterval">setSyncInterval</a></li><li><a href="global.html#setWidth">setWidth</a></li><li><a href="global.html#setupAutoRenewal">setupAutoRenewal</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#showSidebar">showSidebar</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#stopAutoRenewal">stopAutoRenewal</a></li><li><a href="global.html#stopProgressPolling">stopProgressPolling</a></li><li><a href="global.html#success">success</a></li><li><a href="global.html#toggleSidebar">toggleSidebar</a></li><li><a href="global.html#trackingState">trackingState</a></li><li><a href="global.html#updateCardData">updateCardData</a></li><li><a href="global.html#updateSpecificCard">updateSpecificCard</a></li><li><a href="global.html#warning">warning</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">components/SyncDashboard.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Dashboard de SincronizaciÃ³n en Dos Fases
 *
 * Gestiona la interfaz de usuario para el dashboard de sincronizaciÃ³n en dos fases,
 * incluyendo controles de inicio/pausa, visualizaciÃ³n de progreso, y actualizaciÃ³n
 * de estadÃ­sticas en tiempo real.
 *
 * @module components/SyncDashboard
 * @class SyncDashboard
 * @since 1.0.0
 * @author Christian
 * @requires module:types
 */

// @ts-check
/* global jQuery, miIntegracionApiDashboard, DASHBOARD_CONFIG, AjaxManager, pollingManager, addConsoleLine, ajaxurl, ToastManager, SyncStateManager, EventCleanupManager, UIOptimizer, ErrorHandler */

/**
 * Clase SyncDashboard para gestionar el dashboard de dos fases
 *
 * @class SyncDashboard
 * @description GestiÃ³n del dashboard de sincronizaciÃ³n en dos fases
 */
class SyncDashboard {
  /**
   * Constructor de SyncDashboard
   *
   * @constructor
   * @description Inicializa el dashboard y carga el estado actual
   * @property {number|null} phase1Timer - ID del intervalo del timer de Fase 1
   * @property {number|null} phase2Timer - ID del intervalo del timer de Fase 2
   * @property {number|null} phase1StartTime - Timestamp de inicio de Fase 1
   * @property {number|null} phase2StartTime - Timestamp de inicio de Fase 2
   */
  constructor() {
    /** @type {number|null} */
    this.phase1Timer = null;
    /** @type {number|null} */
    this.phase2Timer = null;
    /** @type {number|null} */
    this.phase1StartTime = null;
    /** @type {number|null} */
    this.phase2StartTime = null;
    this.initializeEventListeners();
    this.subscribeToPollingEvents();
    this.loadCurrentStatus();
  }

  /**
   * Suscribirse a eventos de PollingManager para actualizar UI automÃ¡ticamente
   * 
   * âœ… UNIFICADO: SyncDashboard se suscribe a eventos en lugar de iniciar polling directamente.
   * Esto mantiene la responsabilidad clara: PollingManager gestiona polling, SyncDashboard solo actualiza UI.
   * 
   * @returns {void}
   * @private
   */
  subscribeToPollingEvents() {
    if (!window?.pollingManager?.on) {
      return;
    }

    const componentId = 'SyncDashboard';
    
    if (EventCleanupManager?.registerCustomEventListener) {
      EventCleanupManager.registerCustomEventListener(
        window.pollingManager,
        'syncProgress',
        (data) => {
          if (data &amp;&amp; data.syncData) {
            this.updateDashboardFromStatus(data.syncData);
          }
        },
        componentId
      );

      EventCleanupManager.registerCustomEventListener(
        window.pollingManager,
        'syncError',
        (error) => {
          if (addConsoleLine) {
            addConsoleLine('error', error.message ?? 'Error en sincronizaciÃ³n');
          }
          this.updatePhaseStatus(2, 'error');
        },
        componentId
      );

      EventCleanupManager.registerCustomEventListener(
        window.pollingManager,
        'syncCompleted',
        (data) => {
          if (data &amp;&amp; data.phase === 2) {
            this.updatePhaseStatus(2, 'completed');
            this.stopTimer(2);
          }
        },
        componentId
      );

      EventCleanupManager.registerCustomEventListener(
        window.pollingManager,
        'phase1Completed',
        (eventData) => {
          this.updatePhaseStatus(1, 'completed');
          this.stopTimer(1);
          this.enableButton('start-phase2');
          if (eventData &amp;&amp; eventData.data) {
            this.updateDashboardFromStatus(eventData.data);
          }
        },
        componentId
      );
    } else {
      window.pollingManager.on('syncProgress', (data) => {
        if (data &amp;&amp; data.syncData) {
          this.updateDashboardFromStatus(data.syncData);
        }
      });

      window.pollingManager.on('syncError', (error) => {
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', error.message || 'Error en sincronizaciÃ³n');
        }
        this.updatePhaseStatus(2, 'error');
      });

      window.pollingManager.on('syncCompleted', (data) => {
        if (data &amp;&amp; data.phase === 2) {
          this.updatePhaseStatus(2, 'completed');
          this.stopTimer(2);
        }
      });

      window.pollingManager.on('phase1Completed', (eventData) => {
        this.updatePhaseStatus(1, 'completed');
        this.stopTimer(1);
        this.enableButton('start-phase2');
        if (eventData &amp;&amp; eventData.data) {
          this.updateDashboardFromStatus(eventData.data);
        }
      });
    }
  }

  /**
   * Inicializa los event listeners para los controles del dashboard
   *
   * @returns {void}
   * @private
   */
  initializeEventListeners() {
    const componentId = 'SyncDashboard';
    
    if (EventCleanupManager?.registerElementListener) {
      EventCleanupManager.registerElementListener('#start-phase1', 'click', () => this.startPhase1(), componentId);
      EventCleanupManager.registerElementListener('#cancel-phase1', 'click', () => this.cancelPhase1(), componentId);
      EventCleanupManager.registerElementListener('#start-phase2', 'click', () => this.startPhase2(), componentId);
      EventCleanupManager.registerElementListener('#pause-phase2', 'click', () => this.pausePhase2(), componentId);
      EventCleanupManager.registerElementListener('#mi-cancel-sync', 'click', () => this.cancelSync(), componentId);
      EventCleanupManager.registerElementListener('#batch-size', 'change', (e) => this.updateConfig('batch_size', e.target.value), componentId);
      EventCleanupManager.registerElementListener('#throttle-delay', 'change', (e) => this.updateConfig('throttle_delay', e.target.value), componentId);
      EventCleanupManager.registerElementListener('#auto-retry', 'change', (e) => this.updateConfig('auto_retry', e.target.checked), componentId);
    } else {
      jQuery('#start-phase1').on('click', () => this.startPhase1());
      jQuery('#cancel-phase1').on('click', () => this.cancelPhase1());
      jQuery('#start-phase2').on('click', () => this.startPhase2());
      jQuery('#pause-phase2').on('click', () => this.pausePhase2());
      jQuery('#mi-cancel-sync').on('click', () => this.cancelSync());
      jQuery('#batch-size').on('change', (e) => this.updateConfig('batch_size', e.target.value));
      jQuery('#throttle-delay').on('change', (e) => this.updateConfig('throttle_delay', e.target.value));
      jQuery('#auto-retry').on('change', (e) => this.updateConfig('auto_retry', e.target.checked));
    }
  }

  /**
   * Desvincular event listeners del dashboard
   *
   * @returns {void}
   * @private
   */
  cleanupEventListeners() {
    if (EventCleanupManager?.cleanupComponent) {
      EventCleanupManager.cleanupComponent('SyncDashboard');
    } else {
      jQuery('#start-phase1').off('click');
      jQuery('#cancel-phase1').off('click');
      jQuery('#start-phase2').off('click');
      jQuery('#pause-phase2').off('click');
      jQuery('#mi-cancel-sync').off('click');
      jQuery('#batch-size').off('change');
      jQuery('#throttle-delay').off('change');
      jQuery('#auto-retry').off('change');
    }
  }

  /**
   * Inicia la Fase 1: SincronizaciÃ³n de imÃ¡genes
   *
   * @returns {Promise&lt;void>}
   * @async
   */
  async startPhase1() {
    this.updatePhaseStatus(1, 'running');
    this.disableButton('start-phase1');
    this.enableButton('cancel-phase1');
    this.phase1StartTime = Date.now();
    this.startTimer(1);

    if (typeof addConsoleLine === 'function') {
      addConsoleLine('phase1', 'Iniciando Fase 1: SincronizaciÃ³n de imÃ¡genes...');
    }

    try {
      // âœ… CORRECCIÃ“N: Verificar que ajaxurl estÃ© disponible
      const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
        ? ajaxurl 
        : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
          ? miIntegracionApiDashboard.ajaxurl
          : null;

      if (!ajaxUrl) {
        throw new Error('ajaxurl no estÃ¡ disponible');
      }

      const $batchSize = jQuery('#batch-size');
      const batchSizeValue = $batchSize.length ? $batchSize.val() : null;
      const batchSize = batchSizeValue ? parseInt(String(batchSizeValue), 10) || 50 : 50;

      const response = await jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_sync_images',
          nonce: miIntegracionApiDashboard.nonce,
          resume: false,
          batch_size: batchSize
        }
      });

      if (response.success) {
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('success', 'Fase 1 iniciada correctamente');
        }
        
        if (window?.pollingManager?.emit) {
          const phase1Status = response.data?.phase1_images ?? {
            in_progress: true,
            completed: false,
            products_processed: 0,
            total_products: response.data?.total_products ?? 0
          };
          
          window.pollingManager.emit('syncProgress', {
            syncData: response.data ?? {
              in_progress: false,
              is_completed: false
            },
            phase1Status,
            timestamp: Date.now()
          });
        }
        
        if (window?.Phase1Manager) {
          const existingInterval = window.Phase1Manager.getPollingInterval?.();
          if (!existingInterval &amp;&amp; window.Phase1Manager.startPolling) {
            window.Phase1Manager.startPolling();
          }
        }
        
        this.handlePhase1Response(response.data);
      } else {
        const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'Error iniciando Fase 1: ' + errorMsg);
        }
        this.updatePhaseStatus(1, 'error');
        this.enableButton('start-phase1');
      }
    } catch (error) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error iniciando Fase 1: ' + (error.message || 'Error de comunicaciÃ³n'));
      }
      this.updatePhaseStatus(1, 'error');
      this.enableButton('start-phase1');
    }
  }

  /**
   * Inicia la Fase 2: SincronizaciÃ³n de productos
   *
   * @returns {Promise&lt;void>}
   * @async
   */
  async startPhase2() {
    if (SyncStateManager?.getPhase2Starting?.()) {
      // eslint-disable-next-line no-console
      console.warn('âš ï¸ Fase 2 ya se estÃ¡ iniciando, ignorando llamada duplicada');
      return;
    }
    
    if (SyncStateManager?.setPhase2Starting) {
      SyncStateManager.setPhase2Starting(true);
    }
    
    let phase1Status = null;
    let currentStatus = null;
    
    try {
      const statusResponse = await jQuery.ajax({
        url: ajaxurl ?? miIntegracionApiDashboard?.ajaxurl ?? null,
        method: 'POST',
        data: {
          action: 'mia_get_sync_progress',
          nonce: miIntegracionApiDashboard.nonce
        }
      });
      
      if (statusResponse.success &amp;&amp; statusResponse.data) {
        phase1Status = statusResponse.data.phase1_images || {};
        currentStatus = statusResponse.data;
      }
    } catch (error) {
      // Continuar sin estado inicial si falla la obtenciÃ³n
    }
    
    const phase1Completed = phase1Status &amp;&amp; phase1Status.completed === true;
    const phase1InProgress = phase1Status &amp;&amp; phase1Status.in_progress === true;
    const inProgress = currentStatus &amp;&amp; currentStatus.in_progress === true;
    
    if (!phase1Completed &amp;&amp; !phase1InProgress) {
      const message = miIntegracionApiDashboard?.warningPhase2WithoutPhase1 ?? 'âš ï¸ Advertencia: La Fase 1 (sincronizaciÃ³n de imÃ¡genes) no se ha completado. Se recomienda completar la Fase 1 primero para obtener mejores resultados. Â¿Deseas continuar de todos modos?';
      
      if (ToastManager?.show) {
        ToastManager.show('Se recomienda completar la Fase 1 primero', 'warning', 5000);
      }
      
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('warning', 'Advertencia: Iniciando Fase 2 sin completar Fase 1');
      }
      
      const confirmed = confirm(message);
      if (!confirmed) {
        if (SyncStateManager?.setPhase2Starting) {
          SyncStateManager.setPhase2Starting(false);
        }
        return;
      }
    }
    
    if (inProgress) {
      const message = typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.warningPhase2InProgress
        ? miIntegracionApiDashboard.warningPhase2InProgress
        : 'Ya hay una sincronizaciÃ³n en progreso. Â¿Deseas continuar de todos modos?';
      
      if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
        ToastManager.show('Ya hay una sincronizaciÃ³n en progreso', 'warning', 5000);
      }
      
      const confirmed = confirm(message);
      if (!confirmed) {
        if (SyncStateManager?.setPhase2Starting) {
          SyncStateManager.setPhase2Starting(false);
        }
        return;
      }
    }
    
    this.updatePhaseStatus(2, 'running');
    this.disableButton('start-phase2');
    this.phase2StartTime = Date.now();
    this.startTimer(2);
    
    // âœ… NUEVO: Mostrar botÃ³n de cancelar cuando inicia la Fase 2
    this.enableButton('mi-cancel-sync');
    jQuery('#mi-cancel-sync').show();

    if (typeof addConsoleLine === 'function') {
      addConsoleLine('phase2', 'Iniciando Fase 2: SincronizaciÃ³n de productos...');
    }

    try {
      // âœ… CORRECCIÃ“N: Verificar que ajaxurl estÃ© disponible
      const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
        ? ajaxurl 
        : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
          ? miIntegracionApiDashboard.ajaxurl
          : null;

      if (!ajaxUrl) {
        throw new Error('ajaxurl no estÃ¡ disponible');
      }

      const $batchSize = jQuery('#batch-size');
      const batchSizeValue = $batchSize.length ? $batchSize.val() : null;
      const batchSize = batchSizeValue ? parseInt(String(batchSizeValue), 10) || 50 : 50;

      const response = await jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mi_integracion_api_sync_products_batch',
          nonce: miIntegracionApiDashboard.nonce,
          batch_size: batchSize
        }
      });

      if (response.success) {
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('success', 'Fase 2 iniciada correctamente');
        }
      } else {
        const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'Error iniciando Fase 2: ' + errorMsg);
        }
        this.updatePhaseStatus(2, 'error');
        this.enableButton('start-phase2');
      }
    } catch (error) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error iniciando Fase 2: ' + (error.message || 'Error de comunicaciÃ³n'));
      }
      this.updatePhaseStatus(2, 'error');
      this.enableButton('start-phase2');
    } finally {
      if (typeof SyncStateManager !== 'undefined' &amp;&amp; SyncStateManager.setPhase2Starting) {
        SyncStateManager.setPhase2Starting(false);
      }
    }
  }

  /**
   * Actualiza las estadÃ­sticas de la Fase 1
   *
   * @param {Phase1Status} data - Datos de progreso de la Fase 1
   * @param {number} [data.total_products] - Total de productos
   * @param {number} [data.products_processed] - Productos procesados
   * @param {number} [data.images_processed] - ImÃ¡genes procesadas
   * @param {number} [data.duplicates_skipped] - Duplicados omitidos
   * @param {number} [data.errors] - Errores
   * @returns {void}
   */
  updatePhase1Progress(data) {
    const productsProcessed = Number(data.products_processed) || 0;
    const imagesProcessed = Number(data.images_processed) || 0;
    const duplicatesSkipped = Number(data.duplicates_skipped) || 0;
    const errors = Number(data.errors || data.errores) || 0;

    if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
      UIOptimizer.updateTextIfChanged(jQuery('#phase1-products'), productsProcessed, 'phase1-products');
      UIOptimizer.updateTextIfChanged(jQuery('#phase1-images'), imagesProcessed, 'phase1-images');
      UIOptimizer.updateTextIfChanged(jQuery('#phase1-duplicates'), duplicatesSkipped, 'phase1-duplicates');
      UIOptimizer.updateTextIfChanged(jQuery('#phase1-errors'), errors, 'phase1-errors');
    } else {
      jQuery('#phase1-products').text(productsProcessed);
      jQuery('#phase1-images').text(imagesProcessed);
      jQuery('#phase1-duplicates').text(duplicatesSkipped);
      jQuery('#phase1-errors').text(errors);
    }

    if (this.phase1StartTime) {
      const elapsedSeconds = (Date.now() - this.phase1StartTime) / 1000;
      const speed = elapsedSeconds > 0
        ? (productsProcessed / elapsedSeconds).toFixed(2)
        : 0;
      const speedText = speed + ' ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg');
      
      if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
        UIOptimizer.updateTextIfChanged(jQuery('#phase1-speed'), speedText, 'phase1-speed');
      } else {
        jQuery('#phase1-speed').text(speedText);
      }
    }
  }

  /**
   * Actualiza las estadÃ­sticas de la Fase 2
   *
   * @param {SyncProgressData} data - Datos de progreso de la Fase 2
   * @returns {void}
   */
  updatePhase2Progress(data) {
    // âœ… MEJORADO: Asegurar que los datos estÃ©n correctamente estructurados
    const stats = data.estadisticas || {};
    const processed = Number(stats.procesados) || 0;

    // âœ… OPTIMIZADO: Usar UIOptimizer para evitar actualizaciones innecesarias
    if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
      UIOptimizer.updateTextIfChanged(jQuery('#phase2-products'), processed, 'phase2-products');
      UIOptimizer.updateTextIfChanged(jQuery('#phase2-errors'), Number(stats.errores) || 0, 'phase2-errors');
      // âœ… CORRECCIÃ“N: Actualizar campos de creados y actualizados si estÃ¡n disponibles
      if (stats.creados !== undefined) {
        UIOptimizer.updateTextIfChanged(jQuery('#phase2-created'), Number(stats.creados) || 0, 'phase2-created');
      }
      if (stats.actualizados !== undefined) {
        UIOptimizer.updateTextIfChanged(jQuery('#phase2-updated'), Number(stats.actualizados) || 0, 'phase2-updated');
      }
    } else {
      jQuery('#phase2-products').text(processed);
      jQuery('#phase2-errors').text(Number(stats.errores) || 0);
      if (stats.creados !== undefined) {
        jQuery('#phase2-created').text(Number(stats.creados) || 0);
      }
      if (stats.actualizados !== undefined) {
        jQuery('#phase2-updated').text(Number(stats.actualizados) || 0);
      }
    }

    // Actualizar velocidad
    // âœ… CORRECCIÃ“N: Solo calcular velocidad si hay sincronizaciÃ³n activa y tiempo vÃ¡lido
    if (this.phase2StartTime &amp;&amp; processed > 0) {
      const elapsedSeconds = (Date.now() - this.phase2StartTime) / 1000;
      // âœ… CORRECCIÃ“N: Validar que el tiempo transcurrido sea razonable (mÃ­nimo 1 segundo)
      if (elapsedSeconds >= 1) {
        const speed = (processed / elapsedSeconds).toFixed(2);
        const speedText = speed + ' ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg');
        
        // âœ… OPTIMIZADO: Usar UIOptimizer para evitar actualizaciones innecesarias
        if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
          UIOptimizer.updateTextIfChanged(jQuery('#phase2-speed'), speedText, 'phase2-speed');
        } else {
          // Fallback: actualizaciÃ³n directa
          jQuery('#phase2-speed').text(speedText);
        }
      } else {
        // Si el tiempo es muy corto, mostrar 0 para evitar valores imposibles
        const zeroSpeedText = '0 ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg');
        
        // âœ… OPTIMIZADO: Usar UIOptimizer para evitar actualizaciones innecesarias
        if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
          UIOptimizer.updateTextIfChanged(jQuery('#phase2-speed'), zeroSpeedText, 'phase2-speed');
        } else {
          // Fallback: actualizaciÃ³n directa
          jQuery('#phase2-speed').text(zeroSpeedText);
        }
      }
    } else {
      // Si no hay sincronizaciÃ³n activa, mostrar 0
      const zeroSpeedText = '0 ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg');
      
      // âœ… OPTIMIZADO: Usar UIOptimizer para evitar actualizaciones innecesarias
      if (typeof UIOptimizer !== 'undefined' &amp;&amp; UIOptimizer &amp;&amp; typeof UIOptimizer.updateTextIfChanged === 'function') {
        UIOptimizer.updateTextIfChanged(jQuery('#phase2-speed'), zeroSpeedText, 'phase2-speed');
      } else {
        // Fallback: actualizaciÃ³n directa
        jQuery('#phase2-speed').text(zeroSpeedText);
      }
    }
  }

  /**
   * Resetea las estadÃ­sticas de la Fase 1 a valores iniciales
   *
   * @returns {void}
   * @private
   */
  resetPhase1Progress() {
    jQuery('#phase1-products').text('0');
    jQuery('#phase1-images').text('0');
    jQuery('#phase1-duplicates').text('0');
    jQuery('#phase1-errors').text('0');
    jQuery('#phase1-speed').text('0 ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg'));
    jQuery('#phase1-timer').text('00:00:00');
    this.phase1StartTime = null;
  }

  /**
   * Resetea las estadÃ­sticas de la Fase 2 a valores iniciales
   *
   * @returns {void}
   * @private
   */
  resetPhase2Progress() {
    jQuery('#phase2-products').text('0');
    jQuery('#phase2-errors').text('0');
    jQuery('#phase2-created').text('0');
    jQuery('#phase2-updated').text('0');
    jQuery('#phase2-speed').text('0 ' + ((DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.progress &amp;&amp; DASHBOARD_CONFIG.messages.progress.productsPerSec) || 'productos/seg'));
    jQuery('#phase2-timer').text('00:00:00');
    this.phase2StartTime = null;
  }

  /**
   * Actualiza el estado visual de una fase
   *
   * @param {1|2} phase - NÃºmero de fase (1 o 2)
   * @param {PhaseStatus} status - Estado de la fase
   * @returns {void}
   */
  updatePhaseStatus(phase, status) {
    const $statusElement = jQuery(`#phase${phase}-status`);
    $statusElement.removeClass('phase-status-pending phase-status-running phase-status-completed phase-status-error phase-status-paused');
    $statusElement.addClass(`phase-status-${status}`);

    const getStatusMessage = function(key, defaultValue) {
      if (DASHBOARD_CONFIG &amp;&amp; DASHBOARD_CONFIG.messages &amp;&amp; DASHBOARD_CONFIG.messages.status &amp;&amp; DASHBOARD_CONFIG.messages.status[key]) {
        return DASHBOARD_CONFIG.messages.status[key];
      }
      return defaultValue;
    };

    const statusText = {
      'pending': 'â³ ' + getStatusMessage('pending', 'Pendiente'),
      'running': 'ðŸ”„ ' + getStatusMessage('running', 'En Progreso'),
      'completed': 'âœ… ' + getStatusMessage('completed', 'Completado'),
      'error': 'âŒ ' + getStatusMessage('error', 'Error'),
      'paused': 'â¸ ' + getStatusMessage('paused', 'Pausado')
    };

    $statusElement.text(statusText[status] || statusText['pending']);
  }

  /**
   * Inicia el timer para una fase
   *
   * @param {number} phase - NÃºmero de fase (1 o 2)
   * @returns {void}
   */
  startTimer(phase) {
    const timerElement = jQuery(`#phase${phase}-timer`);
    let seconds = 0;

    const timer = setInterval(() => {
      seconds++;
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = seconds % 60;

      timerElement.text(
        `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
      );
    }, 1000);

    if (phase === 1) {
      this.phase1Timer = timer;
    } else {
      this.phase2Timer = timer;
    }
  }

  /**
   * Detiene el timer de una fase
   *
   * @param {number} phase - NÃºmero de fase (1 o 2)
   * @returns {void}
   */
  stopTimer(phase) {
    if (phase === 1 &amp;&amp; this.phase1Timer) {
      clearInterval(this.phase1Timer);
      this.phase1Timer = null;
    } else if (phase === 2 &amp;&amp; this.phase2Timer) {
      clearInterval(this.phase2Timer);
      this.phase2Timer = null;
    }
  }

  /**
   * Cancela la Fase 1
   *
   * @returns {Promise&lt;void>}
   * @async
   */
  async cancelPhase1() {
    const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
      ? ajaxurl 
      : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
        ? miIntegracionApiDashboard.ajaxurl
        : null;

    if (!ajaxUrl) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error: ajaxurl no estÃ¡ disponible');
      }
      return;
    }

    if (!confirm('Â¿EstÃ¡s seguro de que deseas cancelar la sincronizaciÃ³n de imÃ¡genes? El progreso actual se perderÃ¡.')) {
      return;
    }

    try {
      const response = await jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_cancel_images_sync',
          nonce: miIntegracionApiDashboard.nonce
        }
      });

      if (response.success) {
        this.updatePhaseStatus(1, 'cancelled');
        this.stopTimer(1);
        this.disableButton('cancel-phase1');
        this.enableButton('start-phase1');
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('warning', 'Fase 1 cancelada');
        }
        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('Fase 1 cancelada correctamente', 'success', 2000);
        }
      } else {
        const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'Error al cancelar Fase 1: ' + errorMsg);
        }
        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('Error al cancelar Fase 1: ' + errorMsg, 'error', 3000);
        }
      }
    } catch (error) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error al cancelar Fase 1: ' + (error.message || 'Error de comunicaciÃ³n'));
      }
      if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
        ToastManager.show('Error al cancelar Fase 1: ' + (error.message || 'Error de comunicaciÃ³n'), 'error', 3000);
      }
    }
  }

  /**
   * Reanuda la Fase 1 (DEPRECADO - Ya no se usa, se reemplazÃ³ por cancelar)
   *
   * @returns {Promise&lt;void>}
   * @async
   * @deprecated Este mÃ©todo ya no se usa. La Fase 1 ahora solo se puede cancelar, no pausar/reanudar.
   */
  async resumePhase1() {
    const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
      ? ajaxurl 
      : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
        ? miIntegracionApiDashboard.ajaxurl
        : null;

    if (!ajaxUrl) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error: ajaxurl no estÃ¡ disponible');
      }
      return;
    }

    try {
      const $batchSize = jQuery('#batch-size');
      const batchSizeValue = $batchSize.length ? $batchSize.val() : null;
      const batchSize = batchSizeValue ? parseInt(String(batchSizeValue), 10) || 50 : 50;

      const response = await jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_resume_images_sync',
          nonce: miIntegracionApiDashboard.nonce,
          batch_size: batchSize
        }
      });

      if (response.success) {
        // âœ… CORRECCIÃ“N: Llamar al endpoint de sincronizaciÃ³n para reanudar realmente
        const $batchSize = jQuery('#batch-size');
        const resumeBatchSize = ($batchSize.length &amp;&amp; $batchSize.val()) 
          ? parseInt($batchSize.val(), 10) || 50
          : 50;

        jQuery.ajax({
          url: ajaxUrl,
          method: 'POST',
          data: {
            action: 'mia_sync_images',
            nonce: miIntegracionApiDashboard.nonce,
            resume: true,
            batch_size: resumeBatchSize
          },
          success: (syncResponse) => {
            if (syncResponse.success) {
              this.updatePhaseStatus(1, 'running');
              this.phase1StartTime = Date.now() - (this.phase1StartTime ? (Date.now() - this.phase1StartTime) : 0);
              this.startTimer(1);
              this.disableButton('start-phase1');
              this.enableButton('cancel-phase1');
              if (typeof addConsoleLine === 'function') {
                addConsoleLine('info', 'Fase 1 reanudada');
              }
              if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
                ToastManager.show('Fase 1 reanudada correctamente', 'success', 2000);
              }
              if (typeof window !== 'undefined' &amp;&amp; window.Phase1Manager &amp;&amp; typeof window.Phase1Manager.startPolling === 'function') {
                window.Phase1Manager.startPolling();
              }
            } else {
              const errorMsg = (syncResponse.data &amp;&amp; syncResponse.data.message) || 'Error desconocido';
              if (typeof addConsoleLine === 'function') {
                addConsoleLine('error', 'Error al reanudar Fase 1: ' + errorMsg);
              }
              if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
                ToastManager.show('Error al reanudar Fase 1: ' + errorMsg, 'error', 3000);
              }
            }
          },
          error: (xhr, status, error) => {
            const errorMsg = error || 'Error de conexiÃ³n';
            
            if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
              ErrorHandler.logError(`Error al reanudar Fase 1: ${errorMsg} (Status: ${status || 'unknown'})`, 'PHASE1_RESUME');
            }
            
            if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.showConnectionError === 'function') {
              ErrorHandler.showConnectionError(xhr);
            }
            
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('error', 'Error al reanudar Fase 1: ' + errorMsg);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Error al reanudar Fase 1: ' + errorMsg, 'error', 3000);
            }
          }
        });
      } else {
        const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'Error al reanudar Fase 1: ' + errorMsg);
        }
        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('Error al reanudar Fase 1: ' + errorMsg, 'error', 3000);
        }
      }
    } catch (error) {
      const errorMsg = error.message || 'Error de comunicaciÃ³n';
      
      if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
        ErrorHandler.logError(`Error al reanudar Fase 1 (excepciÃ³n): ${errorMsg}`, 'PHASE1_RESUME');
      }
      
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error al reanudar Fase 1: ' + errorMsg);
      }
      if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
        ToastManager.show('Error al reanudar Fase 1: ' + errorMsg, 'error', 3000);
      }
    }
  }

  /**
   * Pausa la Fase 2
   *
   * @returns {void}
   */
  pausePhase2() {
    this.updatePhaseStatus(2, 'paused');
    this.stopTimer(2);
    if (typeof addConsoleLine === 'function') {
      addConsoleLine('warning', 'Fase 2 pausada');
    }
  }

  /**
   * Cancela la sincronizaciÃ³n en curso (Fase 2)
   *
   * @returns {Promise&lt;void>}
   * @async
   */
  async cancelSync() {
    const confirmMessage = typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.confirmCancel
      ? miIntegracionApiDashboard.confirmCancel
      : 'Â¿Seguro que deseas cancelar la sincronizaciÃ³n?';
    
    if (!confirm(confirmMessage)) {
      return;
    }

    if (typeof addConsoleLine === 'function') {
      addConsoleLine('warning', 'Cancelando sincronizaciÃ³n...');
    }

    if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
      ToastManager.show('Cancelando sincronizaciÃ³n...', 'info', 2000);
    }

    try {
      const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
        ? ajaxurl 
        : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
          ? miIntegracionApiDashboard.ajaxurl
          : null;

      if (!ajaxUrl) {
        throw new Error('No se pudo obtener la URL de AJAX');
      }

      const response = await jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_sync_cancel',
          nonce: miIntegracionApiDashboard.nonce
        }
      });

      if (response.success) {
        // âœ… MEJORADO: Detener polling antes de resetear
        if (typeof pollingManager !== 'undefined' &amp;&amp; pollingManager &amp;&amp; typeof pollingManager.stopPolling === 'function') {
          pollingManager.stopPolling('syncProgress');
        }
        
        // âœ… NUEVO: Resetear flag de inicializaciÃ³n de Fase 2
        if (typeof window !== 'undefined' &amp;&amp; window.Phase2Manager &amp;&amp; typeof window.Phase2Manager.reset === 'function') {
          window.Phase2Manager.reset();
        }
        
        // âœ… NUEVO: Resetear flag de inicio de Fase 2 usando SyncStateManager
        if (SyncStateManager?.setPhase2Starting) {
          SyncStateManager.setPhase2Starting(false);
        }
        
        // âœ… NUEVO: Actualizar estado del dashboard
        this.updatePhaseStatus(2, 'pending');
        this.stopTimer(2);
        this.resetPhase2Progress();
        this.disableButton('mi-cancel-sync');
        jQuery('#mi-cancel-sync').hide();
        this.enableButton('start-phase2');

        if (typeof addConsoleLine === 'function') {
          addConsoleLine('info', 'SincronizaciÃ³n cancelada correctamente');
        }

        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('SincronizaciÃ³n cancelada correctamente', 'success', 3000);
        }

        await this.loadCurrentStatus();
      } else {
        const errorMsg = response.data &amp;&amp; response.data.message 
          ? response.data.message 
          : 'Error al cancelar la sincronizaciÃ³n';
        
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'Error cancelando sincronizaciÃ³n: ' + errorMsg);
        }

        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('Error al cancelar: ' + errorMsg, 'error', 5000);
        }
      }
    } catch (error) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error cancelando sincronizaciÃ³n: ' + (error.message || 'Error de comunicaciÃ³n'));
      }

      if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
        ToastManager.show('Error al cancelar: ' + (error.message || 'Error de comunicaciÃ³n'), 'error', 5000);
      }
    }
  }

  /**
   * Habilita un botÃ³n
   *
   * @param {string} id - ID del botÃ³n
   * @returns {void}
   */
  enableButton(id) {
    const $button = jQuery('#' + id);
    if ($button.length) {
      $button.prop('disabled', false);
      $button.show();
    }
  }

  /**
   * Deshabilita un botÃ³n
   *
   * @param {string} id - ID del botÃ³n
   * @returns {void}
   */
  disableButton(id) {
    const $button = jQuery('#' + id);
    if ($button.length) {
      $button.prop('disabled', true);
    }
  }

  /**
   * Actualiza la configuraciÃ³n del dashboard
   *
   * @param {string} key - Clave de configuraciÃ³n
   * @param {string|boolean} value - Valor de configuraciÃ³n
   * @returns {void}
   */
  updateConfig(key, value) {
    const ajaxUrl = (typeof ajaxurl !== 'undefined' &amp;&amp; ajaxurl) 
      ? ajaxurl 
      : (typeof miIntegracionApiDashboard !== 'undefined' &amp;&amp; miIntegracionApiDashboard &amp;&amp; miIntegracionApiDashboard.ajaxurl)
        ? miIntegracionApiDashboard.ajaxurl
        : null;

    if (!ajaxUrl) {
      if (typeof addConsoleLine === 'function') {
        addConsoleLine('error', 'Error: ajaxurl no estÃ¡ disponible');
      }
      return;
    }

    if (key === 'batch_size') {
      if (typeof AjaxManager !== 'undefined' &amp;&amp; AjaxManager &amp;&amp; typeof AjaxManager.call === 'function') {
        AjaxManager.call('mi_integracion_api_save_batch_size', {
          entity: 'productos',
          batch_size: value
        }, function(response) {
          if (response.success) {
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('info', 'ConfiguraciÃ³n de batch size actualizada: ' + value);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('TamaÃ±o de lote actualizado correctamente', 'success', 2000);
            }
          } else {
            const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('error', 'Error al actualizar batch size: ' + errorMsg);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Error al actualizar tamaÃ±o de lote: ' + errorMsg, 'error', 3000);
            }
          }
        });
      } else {
        jQuery.ajax({
          url: ajaxUrl,
          method: 'POST',
          data: {
            action: 'mi_integracion_api_save_batch_size',
            nonce: miIntegracionApiDashboard.nonce,
            entity: 'productos',
            batch_size: value
          },
          success: function(response) {
            if (response.success) {
              if (typeof addConsoleLine === 'function') {
                addConsoleLine('info', 'ConfiguraciÃ³n de batch size actualizada: ' + value);
              }
              if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
                ToastManager.show('TamaÃ±o de lote actualizado correctamente', 'success', 2000);
              }
            } else {
              const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
              if (typeof addConsoleLine === 'function') {
                addConsoleLine('error', 'Error al actualizar batch size: ' + errorMsg);
              }
              if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
                ToastManager.show('Error al actualizar tamaÃ±o de lote: ' + errorMsg, 'error', 3000);
              }
            }
          },
          error: function(xhr, status, error) {
            const errorMsg = error || 'Error de conexiÃ³n';
            
            if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
              ErrorHandler.logError(`Error al actualizar batch size: ${errorMsg} (Status: ${status || 'unknown'})`, 'BATCH_SIZE_UPDATE');
            }
            
            if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.showConnectionError === 'function') {
              ErrorHandler.showConnectionError(xhr);
            }
            
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('error', 'Error al actualizar batch size: ' + errorMsg);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Error al actualizar tamaÃ±o de lote: ' + errorMsg, 'error', 3000);
            }
          }
        });
      }
    } else if (key === 'throttle_delay') {
      // âœ… CORRECCIÃ“N: Validar valor antes de enviar
      const delayMs = parseFloat(value);
      if (isNaN(delayMs) || delayMs &lt; 0 || delayMs > 5000) {
        if (typeof addConsoleLine === 'function') {
          addConsoleLine('error', 'El delay de throttling debe estar entre 0 y 5000 ms');
        }
        if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
          ToastManager.show('El delay de throttling debe estar entre 0 y 5000 ms', 'error', 3000);
        }
        return;
      }

      const delaySeconds = delayMs / 1000;
      jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_update_throttle_delay',
          nonce: miIntegracionApiDashboard.nonce,
          delay: delaySeconds
        },
        success: function(response) {
          if (response.success) {
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('info', 'Delay de throttling actualizado: ' + value + 'ms');
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Delay de throttling actualizado correctamente', 'success', 2000);
            }
          } else {
            const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('error', 'Error al actualizar throttle delay: ' + errorMsg);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Error al actualizar delay de throttling: ' + errorMsg, 'error', 3000);
            }
          }
        },
        error: function(xhr, status, error) {
          const errorMsg = error || 'Error de conexiÃ³n';
          
          if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
            ErrorHandler.logError(`Error al actualizar throttle delay: ${errorMsg} (Status: ${status || 'unknown'})`, 'THROTTLE_DELAY_UPDATE');
          }
          
          if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.showConnectionError === 'function') {
            ErrorHandler.showConnectionError(xhr);
          }
          
          if (typeof addConsoleLine === 'function') {
            addConsoleLine('error', 'Error al actualizar throttle delay: ' + errorMsg);
          }
          if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
            ToastManager.show('Error al actualizar delay de throttling: ' + errorMsg, 'error', 3000);
          }
        }
      });
    } else if (key === 'auto_retry') {
      const autoRetryValue = value === true || value === 'true' || value === 1 || value === '1';
      jQuery.ajax({
        url: ajaxUrl,
        method: 'POST',
        data: {
          action: 'mia_update_auto_retry',
          nonce: miIntegracionApiDashboard.nonce,
          auto_retry: autoRetryValue
        },
        success: function(response) {
          if (response.success) {
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('info', 'ConfiguraciÃ³n de reintento automÃ¡tico actualizada: ' + (autoRetryValue ? 'Activado' : 'Desactivado'));
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show(
                autoRetryValue ? 'Reintento automÃ¡tico activado' : 'Reintento automÃ¡tico desactivado',
                'success',
                2000
              );
            }
          } else {
            const errorMsg = (response.data &amp;&amp; response.data.message) || 'Error desconocido';
            if (typeof addConsoleLine === 'function') {
              addConsoleLine('error', 'Error al actualizar auto retry: ' + errorMsg);
            }
            if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
              ToastManager.show('Error al actualizar reintento automÃ¡tico: ' + errorMsg, 'error', 3000);
            }
          }
        },
        error: function(xhr, status, error) {
          const errorMsg = error || 'Error de conexiÃ³n';
          
          // âœ… MEJORADO: Registrar error usando ErrorHandler
          if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
            ErrorHandler.logError(`Error al actualizar auto retry: ${errorMsg} (Status: ${status || 'unknown'})`, 'AUTO_RETRY_UPDATE');
          }
          
          // âœ… MEJORADO: Mostrar error en UI usando ErrorHandler
          if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.showConnectionError === 'function') {
            ErrorHandler.showConnectionError(xhr);
          }
          
          if (typeof addConsoleLine === 'function') {
            addConsoleLine('error', 'Error al actualizar auto retry: ' + errorMsg);
          }
          if (typeof ToastManager !== 'undefined' &amp;&amp; ToastManager &amp;&amp; typeof ToastManager.show === 'function') {
            ToastManager.show('Error al actualizar reintento automÃ¡tico: ' + errorMsg, 'error', 3000);
          }
        }
      });
    }
  }

  /**
   * Carga el estado actual de sincronizaciÃ³n
   *
   * @returns {Promise&lt;void>}
   * @async
   */
  async loadCurrentStatus() {
    try {
      const response = await jQuery.ajax({
        url: ajaxurl,
        method: 'POST',
        data: {
          action: 'mia_get_sync_progress',
          nonce: miIntegracionApiDashboard.nonce
        }
      });

      if (response.success &amp;&amp; response.data) {
        this.updateDashboardFromStatus(response.data);
        
        const phase1Status = response.data.phase1_images || {};
        const phase1ManagerActive = typeof window !== 'undefined' &amp;&amp; 
                                     window.Phase1Manager &amp;&amp; 
                                     typeof window.Phase1Manager.getPollingInterval === 'function' &amp;&amp;
                                     window.Phase1Manager.getPollingInterval() !== null;
        const syncProgressActive = typeof window !== 'undefined' &amp;&amp; 
                                    window.pollingManager &amp;&amp; 
                                    window.pollingManager.config &amp;&amp;
                                    window.pollingManager.config.currentMode === 'active';
        
        if (!phase1ManagerActive &amp;&amp; !syncProgressActive &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.pollingManager &amp;&amp; typeof window.pollingManager.emit === 'function') {
          window.pollingManager.emit('syncProgress', {
            syncData: response.data,
            phase1Status,
            timestamp: Date.now()
          });
        } else {
          // Fallback: Solo si no hay sistema de eventos disponible
          if (typeof window !== 'undefined' &amp;&amp; typeof window.updateSyncConsole === 'function') {
            window.updateSyncConsole(response.data, phase1Status);
          } else if (typeof window !== 'undefined' &amp;&amp; window.ConsoleManager &amp;&amp; typeof window.ConsoleManager.updateSyncConsole === 'function') {
            window.ConsoleManager.updateSyncConsole(response.data, phase1Status);
          }
        }
      }
    } catch (error) {
      // eslint-disable-next-line no-console
      // Error silenciado - se maneja internamente
    }
  }

  /**
   * Actualiza el dashboard desde los datos de estado
   *
   * @param {SyncProgressData|null} data - Datos de estado de sincronizaciÃ³n
   * @returns {void}
   */
  updateDashboardFromStatus(data) {
    // âœ… CORRECCIÃ“N: Validar que data existe y tiene la estructura correcta
    if (!data || typeof data !== 'object') {
      // Si no hay datos vÃ¡lidos, resetear todo a estado pendiente
      this.updatePhaseStatus(1, 'pending');
      this.updatePhaseStatus(2, 'pending');
      this.resetPhase1Progress();
      this.resetPhase2Progress();
      return;
    }

    // Actualizar estado de Fase 1
    const phase1Status = data.phase1_images || {};
    // âœ… ACTUALIZADO: Manejar estado cancelado
    if (phase1Status.cancelled || phase1Status.completed === false &amp;&amp; !phase1Status.in_progress) {
      this.updatePhaseStatus(1, 'cancelled');
      this.stopTimer(1);
      this.disableButton('cancel-phase1');
      this.enableButton('start-phase1');
      this.updatePhase1Progress(phase1Status);
    } else if (phase1Status.in_progress === true) {
      // âœ… ACTUALIZADO: Verificar explÃ­citamente que in_progress sea true
      this.updatePhaseStatus(1, 'running');
      this.updatePhase1Progress(phase1Status);
      // âœ… ACTUALIZADO: Asegurar que los botones estÃ©n en el estado correcto
      this.disableButton('start-phase1');
      this.enableButton('cancel-phase1');
      if (!this.phase1Timer) {
        this.phase1StartTime = Date.now();
        this.startTimer(1);
      }
      // âœ… CORRECCIÃ“N: Iniciar polling automÃ¡ticamente si hay sincronizaciÃ³n en progreso
      this.startPollingIfNeeded();
    } else if (phase1Status.completed === true) {
      // âœ… CORRECCIÃ“N: Verificar explÃ­citamente que completed sea true
      this.updatePhaseStatus(1, 'completed');
      this.stopTimer(1);
      this.enableButton('start-phase2');
      this.updatePhase1Progress(phase1Status);
    } else {
      this.updatePhaseStatus(1, 'pending');
      this.stopTimer(1);
      this.resetPhase1Progress();
    }
    const stats = data.estadisticas || {};
    const phase2Total = Number(stats.total) || 0;
    const phase2Processed = Number(stats.procesados) || 0;
    const phase2IsInProgress = data.in_progress === true &amp;&amp; !phase1Status.in_progress;
    const phase2IsCompleted = data.is_completed === true &amp;&amp; phase2Total > 0 &amp;&amp; phase2Processed >= phase2Total;
    
    if (phase2IsInProgress) {
      this.updatePhaseStatus(2, 'running');
      this.updatePhase2Progress(data);
      if (!this.phase2Timer) {
        this.phase2StartTime = Date.now();
        this.startTimer(2);
      }
      this.enableButton('mi-cancel-sync');
      jQuery('#mi-cancel-sync').show();
      
      const pollingAlreadyActive = typeof pollingManager !== 'undefined' &amp;&amp; pollingManager &amp;&amp; 
                                    typeof pollingManager.isPollingActive === 'function' &amp;&amp; 
                                    pollingManager.isPollingActive('syncProgress');
      
      const phase2Initialized = typeof SyncStateManager !== 'undefined' &amp;&amp; SyncStateManager.getPhase2Initialized 
        ? SyncStateManager.getPhase2Initialized() 
        : (typeof window !== 'undefined' &amp;&amp; window.phase2Initialized);
      
      if (!phase2Initialized &amp;&amp; !pollingAlreadyActive) {
        this.startPollingIfNeeded();
      }
    } else if (phase2IsCompleted) {
      // âœ… CORRECCIÃ“N: Solo marcar como completado si realmente se completÃ³ (total > 0 y procesados >= total)
      // âœ… NUEVO: Resetear flag de inicializaciÃ³n de Fase 2 cuando se completa
      if (typeof window !== 'undefined' &amp;&amp; window.Phase2Manager &amp;&amp; typeof window.Phase2Manager.reset === 'function') {
        window.Phase2Manager.reset();
      }
      
      this.updatePhaseStatus(2, 'completed');
      this.stopTimer(2);
      this.updatePhase2Progress(data);
      // âœ… NUEVO: Ocultar botÃ³n de cancelar cuando estÃ¡ completado
      this.disableButton('mi-cancel-sync');
      jQuery('#mi-cancel-sync').hide();
    } else {
      // Si no estÃ¡ en progreso ni completada, resetear a estado pendiente
      // âœ… NUEVO: Resetear flag de inicializaciÃ³n de Fase 2 cuando no hay sincronizaciÃ³n activa
      if (typeof window !== 'undefined' &amp;&amp; window.Phase2Manager &amp;&amp; typeof window.Phase2Manager.reset === 'function') {
        window.Phase2Manager.reset();
      }
      
      this.updatePhaseStatus(2, 'pending');
      this.stopTimer(2);
      this.resetPhase2Progress();
      // âœ… CORRECCIÃ“N: Resetear tambiÃ©n el tiempo de inicio para evitar cÃ¡lculos incorrectos
      this.phase2StartTime = null;
      // âœ… NUEVO: Ocultar botÃ³n de cancelar cuando no hay sincronizaciÃ³n
      this.disableButton('mi-cancel-sync');
      jQuery('#mi-cancel-sync').hide();
    }
  }

  /**
   * Inicia el polling automÃ¡ticamente si hay sincronizaciÃ³n en progreso
   *
   * @returns {void}
   * @private
   */
  startPollingIfNeeded() {
    // âœ… UNIFICADO: SyncDashboard NO debe iniciar polling directamente
    // Debe delegar a Phase1Manager o Phase2Manager segÃºn corresponda
    
    // Verificar si Phase2Manager ya estÃ¡ gestionando el polling
    const phase2Initialized = typeof SyncStateManager !== 'undefined' &amp;&amp; SyncStateManager.getPhase2Initialized 
      ? SyncStateManager.getPhase2Initialized() 
      : (typeof window !== 'undefined' &amp;&amp; window.phase2Initialized);
    
    if (phase2Initialized) {
      // Phase2Manager ya estÃ¡ gestionando el polling, no hacer nada
      return;
    }
    
    if (typeof window !== 'undefined' &amp;&amp; window.Phase2Manager &amp;&amp; typeof window.Phase2Manager.start === 'function') {
      // eslint-disable-next-line no-console
      if (typeof console !== 'undefined' &amp;&amp; console.debug) {
        // eslint-disable-next-line no-console
        console.debug('SyncDashboard: Polling necesario pero Phase2Manager no estÃ¡ inicializado');
      }
    }
  }

  /**
   * Maneja la respuesta de inicio de Fase 1
   *
   * @param {Object} data - Datos de respuesta
   * @returns {void}
   */
  handlePhase1Response(data) {
    if (data &amp;&amp; data.in_progress) {
      if (typeof window !== 'undefined' &amp;&amp; window.Phase1Manager &amp;&amp; typeof window.Phase1Manager.startPolling === 'function') {
        window.Phase1Manager.startPolling();
      }
    }
  }
}

/**
 * Exponer SyncDashboard globalmente para mantener compatibilidad
 * con el cÃ³digo existente que usa window.SyncDashboard
 */
// eslint-disable-next-line no-restricted-globals
if (typeof window !== 'undefined') {
  try {
    // eslint-disable-next-line no-restricted-globals
    window.SyncDashboard = SyncDashboard;
  } catch (error) {
    try {
      // eslint-disable-next-line no-restricted-globals
      Object.defineProperty(window, 'SyncDashboard', {
        value: SyncDashboard,
        writable: true,
        enumerable: true,
        configurable: true
      });
    } catch (defineError) {
      // eslint-disable-next-line no-console
    }
  }
}

/* global module */
if (typeof module !== 'undefined' &amp;&amp; module.exports) {
  module.exports = { SyncDashboard };
}

/**
 * FunciÃ³n auxiliar para inicializar SyncDashboard
 * @returns {void}
 */
function initializeSyncDashboard() {
  // Solo inicializar si existe el elemento del dashboard y no hay una instancia previa
  // eslint-disable-next-line no-restricted-globals
  if (typeof window !== 'undefined' &amp;&amp; typeof jQuery !== 'undefined' &amp;&amp; jQuery('#sync-two-phase-dashboard').length &amp;&amp; !window.syncDashboard) {
    try {
      // eslint-disable-next-line no-restricted-globals
      window.syncDashboard = new SyncDashboard();
    } catch (error) {
      // Error silenciado - la inicializaciÃ³n fallÃ³
      // eslint-disable-next-line no-unused-vars
      void error;
    }
  }
}

/**
 * âœ… INICIALIZACIÃ“N AUTOMÃTICA: Crear instancia de SyncDashboard cuando el DOM estÃ© listo
 * Esto asegura que los event listeners se registren correctamente
 */
// eslint-disable-next-line no-restricted-globals
if (typeof window !== 'undefined') {
  // Usar mÃºltiples mÃ©todos para asegurar que se ejecute cuando jQuery estÃ© disponible
  if (typeof jQuery !== 'undefined') {
    jQuery(document).ready(function() {
      initializeSyncDashboard();
    });
  } else {
    // Fallback: esperar a que jQuery estÃ© disponible
    // eslint-disable-next-line no-restricted-globals
    if (typeof window.addEventListener !== 'undefined') {
      // eslint-disable-next-line no-restricted-globals
      window.addEventListener('DOMContentLoaded', function() {
        // Esperar un poco mÃ¡s para que jQuery se cargue
        setTimeout(function() {
          if (typeof jQuery !== 'undefined') {
            initializeSyncDashboard();
          }
        }, 100);
      });
    }
  }
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Thu Nov 13 2025 05:45:58 GMT+0100 (hora estÃ¡ndar de Europa central) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
