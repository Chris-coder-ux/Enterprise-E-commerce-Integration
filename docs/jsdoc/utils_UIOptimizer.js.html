<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>utils/UIOptimizer.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AjaxManager.html">AjaxManager</a><ul class='methods'><li data-type='method'><a href="AjaxManager.html#.call">call</a></li></ul></li><li><a href="ErrorHandler.html">ErrorHandler</a><ul class='methods'><li data-type='method'><a href="ErrorHandler.html#.logError">logError</a></li><li data-type='method'><a href="ErrorHandler.html#.showCancelError">showCancelError</a></li><li data-type='method'><a href="ErrorHandler.html#.showConnectionError">showConnectionError</a></li><li data-type='method'><a href="ErrorHandler.html#.showCriticalError">showCriticalError</a></li><li data-type='method'><a href="ErrorHandler.html#.showProtectionError">showProtectionError</a></li><li data-type='method'><a href="ErrorHandler.html#.showUIError">showUIError</a></li></ul></li><li><a href="EventCleanupManager.html">EventCleanupManager</a><ul class='methods'><li data-type='method'><a href="EventCleanupManager.html#cleanupAll">cleanupAll</a></li><li data-type='method'><a href="EventCleanupManager.html#getStats">getStats</a></li><li data-type='method'><a href="EventCleanupManager.html#.cleanupComponent">cleanupComponent</a></li><li data-type='method'><a href="EventCleanupManager.html#.getInstance">getInstance</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerCustomEventListener">registerCustomEventListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerDocumentListener">registerDocumentListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerElementListener">registerElementListener</a></li><li data-type='method'><a href="EventCleanupManager.html#.registerNativeListener">registerNativeListener</a></li></ul></li><li></li><li></li><li><a href="PollingManager.html">PollingManager</a><ul class='methods'><li data-type='method'><a href="PollingManager.html#adjustPolling">adjustPolling</a></li><li data-type='method'><a href="PollingManager.html#emit">emit</a></li><li data-type='method'><a href="PollingManager.html#getIntervalId">getIntervalId</a></li><li data-type='method'><a href="PollingManager.html#isPollingActive">isPollingActive</a></li><li data-type='method'><a href="PollingManager.html#off">off</a></li><li data-type='method'><a href="PollingManager.html#on">on</a></li><li data-type='method'><a href="PollingManager.html#recordError">recordError</a></li><li data-type='method'><a href="PollingManager.html#recordResponseTime">recordResponseTime</a></li><li data-type='method'><a href="PollingManager.html#reset">reset</a></li><li data-type='method'><a href="PollingManager.html#startPolling">startPolling</a></li><li data-type='method'><a href="PollingManager.html#stopAllPolling">stopAllPolling</a></li><li data-type='method'><a href="PollingManager.html#stopPolling">stopPolling</a></li></ul></li><li></li><li></li><li><a href="SyncDashboard.html">SyncDashboard</a><ul class='methods'><li data-type='method'><a href="SyncDashboard.html#cancelPhase1">cancelPhase1</a></li><li data-type='method'><a href="SyncDashboard.html#cancelSync">cancelSync</a></li><li data-type='method'><a href="SyncDashboard.html#disableButton">disableButton</a></li><li data-type='method'><a href="SyncDashboard.html#enableButton">enableButton</a></li><li data-type='method'><a href="SyncDashboard.html#handlePhase1Response">handlePhase1Response</a></li><li data-type='method'><a href="SyncDashboard.html#loadCurrentStatus">loadCurrentStatus</a></li><li data-type='method'><a href="SyncDashboard.html#pausePhase2">pausePhase2</a></li><li data-type='method'><a href="SyncDashboard.html#resumePhase1">resumePhase1</a></li><li data-type='method'><a href="SyncDashboard.html#startPhase1">startPhase1</a></li><li data-type='method'><a href="SyncDashboard.html#startPhase2">startPhase2</a></li><li data-type='method'><a href="SyncDashboard.html#startTimer">startTimer</a></li><li data-type='method'><a href="SyncDashboard.html#stopTimer">stopTimer</a></li><li data-type='method'><a href="SyncDashboard.html#updateConfig">updateConfig</a></li><li data-type='method'><a href="SyncDashboard.html#updateDashboardFromStatus">updateDashboardFromStatus</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhase1Progress">updatePhase1Progress</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhase2Progress">updatePhase2Progress</a></li><li data-type='method'><a href="SyncDashboard.html#updatePhaseStatus">updatePhaseStatus</a></li></ul></li><li></li><li></li><li><a href="UIOptimizer.html">UIOptimizer</a><ul class='methods'><li data-type='method'><a href="UIOptimizer.html#cancelPendingUpdates">cancelPendingUpdates</a></li><li data-type='method'><a href="UIOptimizer.html#clearCache">clearCache</a></li><li data-type='method'><a href="UIOptimizer.html#scheduleUpdate">scheduleUpdate</a></li><li data-type='method'><a href="UIOptimizer.html#.getInstance">getInstance</a></li><li data-type='method'><a href="UIOptimizer.html#.updateCssIfChanged">updateCssIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateDataIfChanged">updateDataIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateHtmlIfChanged">updateHtmlIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateTextIfChanged">updateTextIfChanged</a></li><li data-type='method'><a href="UIOptimizer.html#.updateValueIfChanged">updateValueIfChanged</a></li></ul></li><li></li><li></li></ul><h3>Modules</h3><ul><li><a href="module-ui_SidebarController.html">ui/SidebarController</a></li><li><a href="module-utils_FormatUtils.html">utils/FormatUtils</a></li></ul><h3>Namespaces</h3><ul><li></li><li><a href="CardManager.html">CardManager</a></li><li></li><li><a href="ConsoleManager.html">ConsoleManager</a></li><li><a href="DASHBOARD_CONFIG.html">DASHBOARD_CONFIG</a></li><li></li><li><a href="global.html#DomUtils">DomUtils</a></li><li></li><li><a href="MESSAGES.html">MESSAGES</a></li><li><a href="global.html#NonceManager">NonceManager</a></li><li><a href="global.html#Phase1Manager">Phase1Manager</a></li><li><a href="global.html#Phase2Manager">Phase2Manager</a></li><li><a href="global.html#ProgressBar">ProgressBar</a></li><li><a href="ResponsiveLayout.html">ResponsiveLayout</a></li><li></li><li><a href="SELECTORS.html">SELECTORS</a></li><li></li><li><a href="global.html#Sanitizer">Sanitizer</a><ul class='methods'><li data-type='method'><a href="global.html#Sanitizer#.escapeHtml">escapeHtml</a></li><li data-type='method'><a href="global.html#Sanitizer#.sanitizeHtml">sanitizeHtml</a></li><li data-type='method'><a href="global.html#Sanitizer#.sanitizeMessage">sanitizeMessage</a></li></ul></li><li><a href="global.html#SyncController">SyncController</a></li><li><a href="global.html#SyncProgress">SyncProgress</a></li><li><a href="global.html#SyncStateManager">SyncStateManager</a></li><li><a href="global.html#SystemEventManager">SystemEventManager</a><ul class='methods'><li data-type='method'><a href="global.html#SystemEventManager#.checkAllSystemsReady">checkAllSystemsReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.checkDependencies">checkDependencies</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitErrorHandlerReady">emitErrorHandlerReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitSystemBaseReady">emitSystemBaseReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.emitUnifiedDashboardReady">emitUnifiedDashboardReady</a></li><li data-type='method'><a href="global.html#SystemEventManager#.getInitializationState">getInitializationState</a></li><li data-type='method'><a href="global.html#SystemEventManager#.init">init</a></li><li data-type='method'><a href="global.html#SystemEventManager#.initializeSystem">initializeSystem</a></li><li data-type='method'><a href="global.html#SystemEventManager#.log">log</a></li><li data-type='method'><a href="global.html#SystemEventManager#.registerSystem">registerSystem</a></li></ul></li><li><a href="global.html#ToastManager">ToastManager</a></li><li><a href="UnifiedDashboard.html">UnifiedDashboard</a><ul class='methods'><li data-type='method'><a href="UnifiedDashboard.html#.init">init</a></li><li data-type='method'><a href="UnifiedDashboard.html#.toggleDebugMode">toggleDebugMode</a></li></ul></li><li></li><li><a href="UnifiedDashboardController.html">UnifiedDashboardController</a></li><li></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_DURATION">DEFAULT_DURATION</a></li><li><a href="global.html#DEFAULT_RENEWAL_INTERVAL">DEFAULT_RENEWAL_INTERVAL</a></li><li><a href="global.html#DEFAULT_SELECTOR">DEFAULT_SELECTOR</a></li><li><a href="global.html#DOM_CACHE">DOM_CACHE</a></li><li><a href="global.html#TOAST_CLASSES">TOAST_CLASSES</a></li><li><a href="global.html#TOAST_COLORS">TOAST_COLORS</a></li><li><a href="global.html#TOAST_ICONS">TOAST_ICONS</a></li><li><a href="global.html#adjustLayout">adjustLayout</a></li><li><a href="global.html#attemptRenewal">attemptRenewal</a></li><li><a href="global.html#check">check</a></li><li><a href="global.html#cleanupOnPageLoad">cleanupOnPageLoad</a></li><li><a href="global.html#cleanupSyncProgressListeners">cleanupSyncProgressListeners</a></li><li><a href="global.html#clearPhase2PollingInterval">clearPhase2PollingInterval</a></li><li><a href="global.html#clearSyncInterval">clearSyncInterval</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getFadeInDuration">getFadeInDuration</a></li><li><a href="global.html#getInactiveProgressCounter">getInactiveProgressCounter</a></li><li><a href="global.html#getLastProgressValue">getLastProgressValue</a></li><li><a href="global.html#getPhase1Initialized">getPhase1Initialized</a></li><li><a href="global.html#getPhase1Starting">getPhase1Starting</a></li><li><a href="global.html#getPhase2Initialized">getPhase2Initialized</a></li><li><a href="global.html#getPhase2PollingInterval">getPhase2PollingInterval</a></li><li><a href="global.html#getPhase2ProcessingBatch">getPhase2ProcessingBatch</a></li><li><a href="global.html#getPhase2Starting">getPhase2Starting</a></li><li><a href="global.html#getPollingInterval">getPollingInterval</a></li><li><a href="global.html#getState">getState</a></li><li><a href="global.html#getSyncInterval">getSyncInterval</a></li><li><a href="global.html#getTrackingState">getTrackingState</a></li><li><a href="global.html#getWidth">getWidth</a></li><li><a href="global.html#hideSidebar">hideSidebar</a></li><li><a href="global.html#inactiveProgressCounter">inactiveProgressCounter</a></li><li><a href="global.html#incrementInactiveProgressCounter">incrementInactiveProgressCounter</a></li><li><a href="global.html#info">info</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initCache">initCache</a></li><li><a href="global.html#initResponsiveMenu">initResponsiveMenu</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeSyncDashboard">initializeSyncDashboard</a></li><li><a href="global.html#isAutoRenewalActive">isAutoRenewalActive</a></li><li><a href="global.html#isAvailable">isAvailable</a></li><li><a href="global.html#isCacheInitialized">isCacheInitialized</a></li><li><a href="global.html#isComplete">isComplete</a></li><li><a href="global.html#isPollingActive">isPollingActive</a></li><li><a href="global.html#phase1Starting">phase1Starting</a></li><li><a href="global.html#phase2Starting">phase2Starting</a></li><li><a href="global.html#pollingManager">pollingManager</a></li><li><a href="global.html#proceedWithSync">proceedWithSync</a></li><li><a href="global.html#processNextBatchAutomatically">processNextBatchAutomatically</a></li><li><a href="global.html#refreshCache">refreshCache</a></li><li><a href="global.html#reinit">reinit</a></li><li><a href="global.html#renewalIntervalId">renewalIntervalId</a></li><li><a href="global.html#reset">reset</a></li><li><a href="global.html#resetAllState">resetAllState</a></li><li><a href="global.html#resetCounters">resetCounters</a></li><li><a href="global.html#resetPhase1State">resetPhase1State</a></li><li><a href="global.html#resetPhase2State">resetPhase2State</a></li><li><a href="global.html#setColor">setColor</a></li><li><a href="global.html#setInactiveProgressCounter">setInactiveProgressCounter</a></li><li><a href="global.html#setLastProgressValue">setLastProgressValue</a></li><li><a href="global.html#setPercentage">setPercentage</a></li><li><a href="global.html#setPhase1Initialized">setPhase1Initialized</a></li><li><a href="global.html#setPhase1Starting">setPhase1Starting</a></li><li><a href="global.html#setPhase2Initialized">setPhase2Initialized</a></li><li><a href="global.html#setPhase2PollingInterval">setPhase2PollingInterval</a></li><li><a href="global.html#setPhase2ProcessingBatch">setPhase2ProcessingBatch</a></li><li><a href="global.html#setPhase2Starting">setPhase2Starting</a></li><li><a href="global.html#setSyncInterval">setSyncInterval</a></li><li><a href="global.html#setWidth">setWidth</a></li><li><a href="global.html#setupAutoRenewal">setupAutoRenewal</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#showSidebar">showSidebar</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#stopAutoRenewal">stopAutoRenewal</a></li><li><a href="global.html#stopProgressPolling">stopProgressPolling</a></li><li><a href="global.html#success">success</a></li><li><a href="global.html#toggleSidebar">toggleSidebar</a></li><li><a href="global.html#trackingState">trackingState</a></li><li><a href="global.html#updateCardData">updateCardData</a></li><li><a href="global.html#updateSpecificCard">updateSpecificCard</a></li><li><a href="global.html#warning">warning</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">utils/UIOptimizer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Optimizador de Actualizaciones de UI
 * 
 * Gestiona actualizaciones de UI de forma eficiente evitando cambios innecesarios
 * y usando requestAnimationFrame para actualizaciones visuales frecuentes.
 * 
 * @module utils/UIOptimizer
 * @class UIOptimizer
 * @since 1.0.0
 * @author Christian
 */

/* global ErrorHandler */

/**
 * Clase para optimizar actualizaciones de UI
 * 
 * @class UIOptimizer
 * @description Gestión eficiente de actualizaciones de UI con comparación de datos y requestAnimationFrame
 * 
 * @example
 * // Actualizar texto solo si cambió
 * UIOptimizer.updateTextIfChanged($element, 'Nuevo texto', 'text-key');
 * 
 * // Actualizar con requestAnimationFrame
 * UIOptimizer.scheduleUpdate(() => {
 *   $element.text('Nuevo texto');
 * });
 */
class UIOptimizer {
  /**
   * Constructor de UIOptimizer
   * 
   * @constructor
   */
  constructor() {
    // Cache de valores anteriores para comparación
    this.valueCache = new Map();
    
    // Cola de actualizaciones pendientes para requestAnimationFrame
    this.updateQueue = [];
    this.rafId = null;
    this.isProcessingQueue = false;
    
    // Configuración
    this.config = {
      // Umbral mínimo de cambio para considerar significativo (porcentaje)
      changeThreshold: 0.1, // 0.1% de cambio mínimo
      
      // Tiempo máximo entre actualizaciones (ms)
      maxUpdateInterval: 100, // 100ms = ~10 actualizaciones por segundo máximo
      
      // Último tiempo de actualización
      lastUpdateTime: 0,
      
      // Habilitar comparación profunda de objetos
      deepCompare: true
    };
  }

  /**
   * Compara dos valores para determinar si han cambiado significativamente
   * 
   * @param {*} oldValue - Valor anterior
   * @param {*} newValue - Valor nuevo
   * @param {string} key - Clave única para el valor (opcional)
   * @returns {boolean} true si el cambio es significativo, false en caso contrario
   * @private
   */
  hasSignificantChange(oldValue, newValue, key = null) {
    // Si no hay valor anterior, siempre actualizar
    if (oldValue === undefined || oldValue === null) {
      return true;
    }
    
    // Comparación estricta para valores primitivos
    if (oldValue === newValue) {
      return false;
    }
    
    // Comparación de números con umbral
    if (typeof oldValue === 'number' &amp;&amp; typeof newValue === 'number') {
      const change = Math.abs(newValue - oldValue);
      const percentChange = oldValue !== 0 ? (change / Math.abs(oldValue)) * 100 : change;
      return percentChange >= this.config.changeThreshold;
    }
    
    // Comparación de strings
    if (typeof oldValue === 'string' &amp;&amp; typeof newValue === 'string') {
      return oldValue !== newValue;
    }
    
    // Comparación profunda de objetos si está habilitada
    if (this.config.deepCompare &amp;&amp; typeof oldValue === 'object' &amp;&amp; typeof newValue === 'object') {
      return this.deepCompareObjects(oldValue, newValue);
    }
    
    // Por defecto, considerar como cambio significativo
    return true;
  }

  /**
   * Compara dos objetos de forma profunda
   * 
   * @param {Object} obj1 - Primer objeto
   * @param {Object} obj2 - Segundo objeto
   * @returns {boolean} true si son diferentes, false si son iguales
   * @private
   */
  deepCompareObjects(obj1, obj2) {
    // Comparación rápida de referencias
    if (obj1 === obj2) {
      return false;
    }
    
    // Comparar claves
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) {
      return true;
    }
    
    // Comparar valores de cada clave
    for (const key of keys1) {
      const val1 = obj1[key];
      const val2 = obj2[key];
      
      // Comparar tipos
      if (typeof val1 !== typeof val2) {
        return true;
      }
      
      // Comparar valores primitivos
      if (val1 !== val2) {
        // Si son números, usar umbral
        if (typeof val1 === 'number' &amp;&amp; typeof val2 === 'number') {
          const change = Math.abs(val2 - val1);
          const percentChange = val1 !== 0 ? (change / Math.abs(val1)) * 100 : change;
          if (percentChange >= this.config.changeThreshold) {
            return true;
          }
        } else {
          // Para otros tipos, cualquier diferencia es significativa
          return true;
        }
      }
    }
    
    return false;
  }

  /**
   * Actualiza el texto de un elemento solo si cambió significativamente
   * 
   * @param {jQuery|HTMLElement} element - Elemento jQuery o DOM a actualizar
   * @param {string} newText - Nuevo texto
   * @param {string} cacheKey - Clave única para cache (opcional, se genera automáticamente si no se proporciona)
   * @returns {boolean} true si se actualizó, false si no había cambio significativo
   * 
   * @example
   * UIOptimizer.updateTextIfChanged($('#progress'), '50%', 'progress-text');
   */
  static updateTextIfChanged(element, newText, cacheKey = null) {
    if (!element) {
      return false;
    }
    
    const $element = typeof jQuery !== 'undefined' &amp;&amp; element instanceof jQuery 
      ? element 
      : typeof jQuery !== 'undefined' 
        ? jQuery(element) 
        : null;
    
    if (!$element || $element.length === 0) {
      return false;
    }
    
    // Generar clave de cache si no se proporciona
    const key = cacheKey || `text-${$element.attr('id') || $element.attr('class') || 'unknown'}`;
    
    // Obtener instancia singleton
    const optimizer = UIOptimizer.getInstance();
    
    // Obtener valor anterior del cache
    const oldText = optimizer.valueCache.get(key);
    
    // Comparar valores
    if (!optimizer.hasSignificantChange(oldText, newText, key)) {
      return false; // No hay cambio significativo
    }
    
    // Actualizar cache
    optimizer.valueCache.set(key, newText);
    
    // Programar actualización con requestAnimationFrame
    optimizer.scheduleUpdate(() => {
      try {
        $element.text(newText);
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error actualizando texto: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    return true;
  }

  /**
   * Actualiza el HTML de un elemento solo si cambió significativamente
   * 
   * ⚠️ ADVERTENCIA: Solo usar con HTML seguro (ya sanitizado)
   * 
   * @param {jQuery|HTMLElement} element - Elemento jQuery o DOM a actualizar
   * @param {string} newHtml - Nuevo HTML
   * @param {string} cacheKey - Clave única para cache
   * @returns {boolean} true si se actualizó, false si no había cambio significativo
   */
  static updateHtmlIfChanged(element, newHtml, cacheKey) {
    if (!element || !cacheKey) {
      return false;
    }
    
    const $element = typeof jQuery !== 'undefined' &amp;&amp; element instanceof jQuery 
      ? element 
      : typeof jQuery !== 'undefined' 
        ? jQuery(element) 
        : null;
    
    if (!$element || $element.length === 0) {
      return false;
    }
    
    // Obtener instancia singleton
    const optimizer = UIOptimizer.getInstance();
    
    // Obtener valor anterior del cache
    const oldHtml = optimizer.valueCache.get(cacheKey);
    
    // Comparar valores
    if (!optimizer.hasSignificantChange(oldHtml, newHtml, cacheKey)) {
      return false; // No hay cambio significativo
    }
    
    // Actualizar cache
    optimizer.valueCache.set(cacheKey, newHtml);
    
    // Programar actualización con requestAnimationFrame
    optimizer.scheduleUpdate(() => {
      try {
        $element.html(newHtml);
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error actualizando HTML: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    return true;
  }

  /**
   * Actualiza el valor de un elemento solo si cambió significativamente
   * 
   * @param {jQuery|HTMLElement} element - Elemento jQuery o DOM a actualizar
   * @param {string|number} newValue - Nuevo valor
   * @param {string} cacheKey - Clave única para cache
   * @returns {boolean} true si se actualizó, false si no había cambio significativo
   */
  static updateValueIfChanged(element, newValue, cacheKey) {
    if (!element || !cacheKey) {
      return false;
    }
    
    const $element = typeof jQuery !== 'undefined' &amp;&amp; element instanceof jQuery 
      ? element 
      : typeof jQuery !== 'undefined' 
        ? jQuery(element) 
        : null;
    
    if (!$element || $element.length === 0) {
      return false;
    }
    
    // Obtener instancia singleton
    const optimizer = UIOptimizer.getInstance();
    
    // Obtener valor anterior del cache
    const oldValue = optimizer.valueCache.get(cacheKey);
    
    // Comparar valores
    if (!optimizer.hasSignificantChange(oldValue, newValue, cacheKey)) {
      return false; // No hay cambio significativo
    }
    
    // Actualizar cache
    optimizer.valueCache.set(cacheKey, newValue);
    
    // Programar actualización con requestAnimationFrame
    optimizer.scheduleUpdate(() => {
      try {
        $element.val(newValue);
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error actualizando valor: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    return true;
  }

  /**
   * Actualiza el CSS de un elemento solo si cambió significativamente
   * 
   * @param {jQuery|HTMLElement} element - Elemento jQuery o DOM a actualizar
   * @param {string|Object} property - Propiedad CSS o objeto con propiedades
   * @param {string|number} value - Valor CSS (si property es string)
   * @param {string} cacheKey - Clave única para cache
   * @returns {boolean} true si se actualizó, false si no había cambio significativo
   */
  static updateCssIfChanged(element, property, value, cacheKey) {
    if (!element || !cacheKey) {
      return false;
    }
    
    const $element = typeof jQuery !== 'undefined' &amp;&amp; element instanceof jQuery 
      ? element 
      : typeof jQuery !== 'undefined' 
        ? jQuery(element) 
        : null;
    
    if (!$element || $element.length === 0) {
      return false;
    }
    
    // Obtener instancia singleton
    const optimizer = UIOptimizer.getInstance();
    
    // Construir valor de cache
    const newCssValue = typeof property === 'object' ? JSON.stringify(property) : `${property}:${value}`;
    
    // Obtener valor anterior del cache
    const oldCssValue = optimizer.valueCache.get(cacheKey);
    
    // Comparar valores
    if (!optimizer.hasSignificantChange(oldCssValue, newCssValue, cacheKey)) {
      return false; // No hay cambio significativo
    }
    
    // Actualizar cache
    optimizer.valueCache.set(cacheKey, newCssValue);
    
    // Programar actualización con requestAnimationFrame
    optimizer.scheduleUpdate(() => {
      try {
        if (typeof property === 'object') {
          $element.css(property);
        } else {
          $element.css(property, value);
        }
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error actualizando CSS: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    return true;
  }

  /**
   * Actualiza un objeto de datos completo comparando cambios significativos
   * 
   * @param {Object} data - Objeto con los nuevos datos
   * @param {string} cacheKey - Clave única para cache
   * @param {Function} updateCallback - Función callback que recibe los datos y actualiza la UI
   * @returns {boolean} true si hubo cambios significativos y se actualizó, false en caso contrario
   */
  static updateDataIfChanged(data, cacheKey, updateCallback) {
    if (!data || !cacheKey || typeof updateCallback !== 'function') {
      return false;
    }
    
    // Obtener instancia singleton
    const optimizer = UIOptimizer.getInstance();
    
    // Obtener datos anteriores del cache
    const oldData = optimizer.valueCache.get(cacheKey);
    
    // Comparar datos
    if (!optimizer.hasSignificantChange(oldData, data, cacheKey)) {
      return false; // No hay cambio significativo
    }
    
    // Actualizar cache
    optimizer.valueCache.set(cacheKey, JSON.parse(JSON.stringify(data))); // Deep copy
    
    // Programar actualización con requestAnimationFrame
    optimizer.scheduleUpdate(() => {
      try {
        updateCallback(data);
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error en callback de actualización: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    return true;
  }

  /**
   * Programa una actualización usando requestAnimationFrame
   * 
   * @param {Function} updateFunction - Función a ejecutar en el próximo frame
   * @returns {void}
   */
  scheduleUpdate(updateFunction) {
    if (typeof updateFunction !== 'function') {
      return;
    }
    
    // Agregar a la cola
    this.updateQueue.push(updateFunction);
    
    // Si ya hay un RAF programado, no programar otro
    if (this.rafId !== null) {
      return;
    }
    
    // Verificar throttling basado en tiempo
    const now = Date.now();
    const timeSinceLastUpdate = now - this.config.lastUpdateTime;
    
    if (timeSinceLastUpdate &lt; this.config.maxUpdateInterval &amp;&amp; this.updateQueue.length > 0) {
      // Esperar hasta que pase el intervalo mínimo
      const delay = this.config.maxUpdateInterval - timeSinceLastUpdate;
      setTimeout(() => {
        this.processUpdateQueue();
      }, delay);
      return;
    }
    
    // Programar procesamiento con requestAnimationFrame
    if (typeof requestAnimationFrame !== 'undefined') {
      this.rafId = requestAnimationFrame(() => {
        this.processUpdateQueue();
      });
    } else {
      // Fallback para entornos sin requestAnimationFrame
      setTimeout(() => {
        this.processUpdateQueue();
      }, 16); // ~60fps
    }
  }

  /**
   * Procesa la cola de actualizaciones pendientes
   * 
   * @returns {void}
   * @private
   */
  processUpdateQueue() {
    if (this.isProcessingQueue) {
      return; // Ya se está procesando
    }
    
    this.isProcessingQueue = true;
    this.rafId = null;
    this.config.lastUpdateTime = Date.now();
    
    // Procesar todas las actualizaciones en la cola
    const queue = this.updateQueue.slice(); // Copiar cola
    this.updateQueue = []; // Limpiar cola
    
    queue.forEach((updateFunction) => {
      try {
        updateFunction();
      } catch (error) {
        if (typeof ErrorHandler !== 'undefined' &amp;&amp; ErrorHandler &amp;&amp; typeof ErrorHandler.logError === 'function') {
          ErrorHandler.logError(`Error procesando actualización de UI: ${error.message || error}`, 'UI_UPDATE');
        }
      }
    });
    
    this.isProcessingQueue = false;
    
    // Si se agregaron más actualizaciones mientras se procesaba, programar otra pasada
    if (this.updateQueue.length > 0) {
      if (typeof requestAnimationFrame !== 'undefined') {
        this.rafId = requestAnimationFrame(() => {
          this.processUpdateQueue();
        });
      } else {
        setTimeout(() => {
          this.processUpdateQueue();
        }, 16);
      }
    }
  }

  /**
   * Limpia el cache de valores
   * 
   * @param {string} [key] - Clave específica a limpiar (opcional, si no se proporciona limpia todo)
   * @returns {void}
   */
  clearCache(key = null) {
    if (key) {
      this.valueCache.delete(key);
    } else {
      this.valueCache.clear();
    }
  }

  /**
   * Cancela todas las actualizaciones pendientes
   * 
   * @returns {void}
   */
  cancelPendingUpdates() {
    this.updateQueue = [];
    if (this.rafId !== null &amp;&amp; typeof cancelAnimationFrame !== 'undefined') {
      cancelAnimationFrame(this.rafId);
      this.rafId = null;
    }
  }

  /**
   * Obtiene la instancia singleton de UIOptimizer
   * 
   * @static
   * @returns {UIOptimizer} Instancia de UIOptimizer
   */
  static getInstance() {
    if (!UIOptimizer.instance) {
      UIOptimizer.instance = new UIOptimizer();
    }
    return UIOptimizer.instance;
  }
}

// Instancia singleton
UIOptimizer.instance = null;

/**
 * Exponer UIOptimizer globalmente
 */
(function exposeUIOptimizer() {
  if (typeof window === 'undefined') {
    return;
  }
  
  // Método 1: Asignación directa
  try {
    window.UIOptimizer = UIOptimizer;
    if (window.UIOptimizer === UIOptimizer) {
      return; // ✅ Éxito
    }
  } catch (error) {
    // Continuar con siguiente método
  }
  
  // Método 2: Object.defineProperty
  try {
    Object.defineProperty(window, 'UIOptimizer', {
      value: UIOptimizer,
      writable: true,
      enumerable: true,
      configurable: true
    });
    if (window.UIOptimizer === UIOptimizer) {
      return; // ✅ Éxito
    }
  } catch (defineError) {
    // ✅ SEGURIDAD: No usar eval como fallback
    if (typeof console !== 'undefined' &amp;&amp; console.warn) {
      // eslint-disable-next-line no-console
      console.warn('[UIOptimizer] ⚠️ No se pudo exponer UIOptimizer usando métodos seguros:', defineError);
    }
  }
})();

/* global module */
if (typeof module !== 'undefined' &amp;&amp; module.exports) {
  module.exports = { UIOptimizer };
}

</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.5</a> on Thu Nov 13 2025 05:45:58 GMT+0100 (hora estándar de Europa central) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
